##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.31A/W32 EVALUATION    09/Jan/2016  14:29:15 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\bmp\bmp085.c                                #
#    Command line    =  H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\bmp\bmp085.c -lC                            #
#                       H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\FLASH_Debug\Lis #
#                       t\ -o H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6- #
#                       27ห๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ #
#                       +LQR_2014_7_31\AT91SAM7SE-USART_USB\Compil\FLASH_Deb #
#                       ug\Obj\ -z9 --debug --cpu_mode thumb --endian        #
#                       little --cpu ARM7TDMI --stack_align 4 --interwork    #
#                       -e --fpu None --ec++ --dlib_config                   #
#                       D:\IAREWE431\ARM\LIB\dl4tptinl8n.h -I                #
#                       H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\srcIAR\ -I      #
#                       H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\..\src\ -I      #
#                       H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\ -I       #
#                       H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\kalman\   #
#                       -I H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห #
#                       ๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQ #
#                       R_2014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\pcm\   #
#                       -I H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห #
#                       ๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQ #
#                       R_2014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\spi\   #
#                       -I H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห #
#                       ๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQ #
#                       R_2014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\timer\ #
#                        -I H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27 #
#                       ห๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+L #
#                       QR_2014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\pid\  #
#                       -I H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห #
#                       ๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQ #
#                       R_2014_7_31\AT91SAM7SE-USART_USB\Compil\..\..\avcs\  #
#                       -I D:\IAREWE431\ARM\INC\                             #
#    List file       =  H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\FLASH_Debug\Lis #
#                       t\bmp085.lst                                         #
#    Object file     =  H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ #
#                       \ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2 #
#                       014_7_31\AT91SAM7SE-USART_USB\Compil\FLASH_Debug\Obj #
#                       \bmp085.r79                                          #
#                                                                            #
#                                                                            #
##############################################################################

H:\สตั้สานคื๗2015-8-20\2014-10-1สตั้สา\2015-6-27ห๘ฮฒ\ะกึฑษป๚ด๚ย๋ฒโสิ1-9\ะกึฑษป๚ด๚ย๋ฒโสิ\ยทพถนๆปฎ+LQR_2014_7_31\bmp\bmp085.c
      1          #include <includs.h>
      2          
      3          

   \                                 In segment DATA_Z, align 4, align-sorted
      4          struct bmp085_t  bmp085;
   \                     bmp085:
   \   00000000                      DS8 40
      5          struct bmp085_t * p_bmp085=&bmp085; 
      6          

   \                                 In segment DATA_Z, align 1, align-sorted
      7          volatile  bool compass_update_flag = false; //Compassธะยฑ๊ึพ
   \                     compass_update_flag:
   \   00000000                      DS8 1
      8          char bmp_update_flag=0;
      9          char imu_num=0;
     10          //char bmphmc_num = 0;
     11          char scp_num = 0;
     12          //bool imu_compass_update = false;
     13          char HDG=2;
     14          volatile  char imu_update_flag=0;
     15          bool   raw_imu_update=false;
     16          unsigned int  imu_count = 0;
     17          //char read_compass=0;
     18          int timer0_num=0;

   \                                 In segment DATA_Z, align 4, align-sorted
     19          int flag = 0;
   \                     flag:
   \   00000000                      DS8 4
     20          
     21          /**< pointer to SMD500 / BMP085 device area */
     22          unsigned long up = 0;
     23          unsigned long ut = 0;
     24          short temperature = 0;
     25          long pressure = 0;
     26          double bmp_height = 0.0;
     27          double scp_height = 0.0;
     28          double zero_scp_height=0.0;
     29          double zero_bmp_height=0.0;
     30          double scp_pressure = 0;
     31          double lidar_lite_distance = 0.0;
     32          

   \                                 In segment DATA_Z, align 4, align-sorted
     33          long pni_value[3] = {0,0,0};
   \                     pni_value:
   \   00000000                      DS8 12
     34          unsigned char scp_status = 0;

   \                                 In segment DATA_Z, align 1, align-sorted
     35          unsigned char scp_opstatus = 0;
   \                     scp_opstatus:
   \   00000000                      DS8 1
     36          
     37          //----------------------------------------------------------------
     38          
     39          

   \                                 In segment CODE, align 4, keep-with-next
     40          unsigned int bmp085_t::BMP085_BUS_WRITE_FUNC(const AT91PS_TWI pTwi ,int mode, int int_address, unsigned char *data2send, unsigned int nb)
     41          {
   \                     ??BMP085_BUS_WRITE_FUNC:
   \   00000000   F0B5               PUSH        {R4-R7,LR}
     42          	unsigned int status,counter=0,error=0;
   \   00000002   0025               MOV         R5,#+0
   \   00000004   0020               MOV         R0,#+0
     43                  unsigned int temp=0;
   \   00000006   2C1C               MOV         R4,R5
     44          	// Set TWI Internal Address Register
     45          	if ((mode & AT91C_TWI_IADRSZ) != 0) pTwi->TWI_IADR = int_address;
   \   00000008   C026               MOV         R6,#+192
   \   0000000A   B600               LSL         R6,R6,#+2          ;; #+768
   \   0000000C   3242               TST         R2,R6
   \   0000000E   00D0               BEQ         ??BMP085_BUS_WRITE_FUNC_1
   \   00000010   CB60               STR         R3,[R1, #+12]
     46          
     47          	// Set the TWI Master Mode Register
     48          	  pTwi->TWI_MMR = mode & ~AT91C_TWI_MREAD;
   \                     ??BMP085_BUS_WRITE_FUNC_1:
   \   00000012   1E4B               LDR         R3,??BMP085_BUS_WRITE_FUNC_2  ;; 0xffffefff
   \   00000014   1340               AND         R3,R2
   \   00000016   4B60               STR         R3,[R1, #+4]
     49          	if(nb <2){
   \   00000018   ....               LDR         R2,??DataTable1    ;; 0x7d1
   \   0000001A   8023               MOV         R3,#+128
   \   0000001C   5B00               LSL         R3,R3,#+1          ;; #+256
   \   0000001E   069E               LDR         R6,[SP, #+24]
   \   00000020   022E               CMP         R6,#+2
   \   00000022   05D2               BCS         ??BMP085_BUS_WRITE_FUNC_3
     50          		pTwi->TWI_CR = AT91C_TWI_START | AT91C_TWI_MSEN | AT91C_TWI_STOP;
   \   00000024   0725               MOV         R5,#+7
   \   00000026   0D60               STR         R5,[R1, #+0]
     51          		pTwi->TWI_THR = *data2send;
   \   00000028   059D               LDR         R5,[SP, #+20]
   \   0000002A   2D78               LDRB        R5,[R5, #+0]
   \   0000002C   4D63               STR         R5,[R1, #+52]
   \   0000002E   1EE0               B           ??BMP085_BUS_WRITE_FUNC_4
     52          	}
     53          	else
     54          	{
     55          	// Set the TWI Master Mode Register
     56          	  for(counter=0;counter<nb;counter++){
   \                     ??BMP085_BUS_WRITE_FUNC_3:
   \   00000030   0026               MOV         R6,#+0
     57                    pTwi->TWI_CR = AT91C_TWI_START | AT91C_TWI_MSEN;
   \                     ??BMP085_BUS_WRITE_FUNC_5:
   \   00000032   0527               MOV         R7,#+5
   \   00000034   0F60               STR         R7,[R1, #+0]
     58                    if (counter == (nb - 1)) pTwi->TWI_CR = AT91C_TWI_STOP;
   \   00000036   069F               LDR         R7,[SP, #+24]
   \   00000038   7F1E               SUB         R7,R7,#+1
   \   0000003A   BE42               CMP         R6,R7
   \   0000003C   01D1               BNE         ??BMP085_BUS_WRITE_FUNC_6
   \   0000003E   0227               MOV         R7,#+2
   \   00000040   0F60               STR         R7,[R1, #+0]
     59                    status = pTwi->TWI_SR;
   \                     ??BMP085_BUS_WRITE_FUNC_6:
   \   00000042   0F6A               LDR         R7,[R1, #+32]
     60                    if ((status & ERROR) == ERROR) error++;
   \   00000044   1F42               TST         R7,R3
   \   00000046   02D0               BEQ         ??BMP085_BUS_WRITE_FUNC_7
   \   00000048   401C               ADD         R0,R0,#+1
   \   0000004A   00E0               B           ??BMP085_BUS_WRITE_FUNC_7
     61                    while (!(status & AT91C_TWI_TXRDY_MASTER))
     62                    {
     63                         status = pTwi->TWI_SR;
     64                         if ((status & ERROR) == ERROR) error++;
     65                         if(temp >2000)
     66                          {
     67                            temp=0;
     68                            break;
     69                          } 
     70                         temp ++;
   \                     ??BMP085_BUS_WRITE_FUNC_8:
   \   0000004C   641C               ADD         R4,R4,#+1
   \                     ??BMP085_BUS_WRITE_FUNC_7:
   \   0000004E   7F07               LSL         R7,R7,#+29
   \   00000050   06D4               BMI         ??BMP085_BUS_WRITE_FUNC_9
   \   00000052   0F6A               LDR         R7,[R1, #+32]
   \   00000054   1F42               TST         R7,R3
   \   00000056   00D0               BEQ         ??BMP085_BUS_WRITE_FUNC_10
   \   00000058   401C               ADD         R0,R0,#+1
   \                     ??BMP085_BUS_WRITE_FUNC_10:
   \   0000005A   9442               CMP         R4,R2
   \   0000005C   F6D3               BCC         ??BMP085_BUS_WRITE_FUNC_8
   \   0000005E   0024               MOV         R4,#+0
     71                    }
     72                    pTwi->TWI_THR = *(data2send+counter);
   \                     ??BMP085_BUS_WRITE_FUNC_9:
   \   00000060   059F               LDR         R7,[SP, #+20]
   \   00000062   BF5D               LDRB        R7,[R7, R6]
   \   00000064   4F63               STR         R7,[R1, #+52]
     73          	   }
   \   00000066   761C               ADD         R6,R6,#+1
   \   00000068   069F               LDR         R7,[SP, #+24]
   \   0000006A   BE42               CMP         R6,R7
   \   0000006C   E1D3               BCC         ??BMP085_BUS_WRITE_FUNC_5
     74          	}
     75          	status = pTwi->TWI_SR;
   \                     ??BMP085_BUS_WRITE_FUNC_4:
   \   0000006E   0D6A               LDR         R5,[R1, #+32]
     76          	if ((status & ERROR) == ERROR) error++;
   \   00000070   1D42               TST         R5,R3
   \   00000072   02D0               BEQ         ??BMP085_BUS_WRITE_FUNC_11
   \   00000074   401C               ADD         R0,R0,#+1
   \   00000076   00E0               B           ??BMP085_BUS_WRITE_FUNC_11
     77          	while (!(status & AT91C_TWI_TXCOMP_MASTER))
     78                  {
     79              		status = pTwi->TWI_SR;
     80              		if ((status & ERROR) == ERROR) error++;
     81                          if(temp >2000)
     82                          {
     83                            temp=0;
     84                            break;
     85                          } 
     86                          temp ++;
   \                     ??BMP085_BUS_WRITE_FUNC_12:
   \   00000078   641C               ADD         R4,R4,#+1
   \                     ??BMP085_BUS_WRITE_FUNC_11:
   \   0000007A   ED07               LSL         R5,R5,#+31
   \   0000007C   05D4               BMI         ??BMP085_BUS_WRITE_FUNC_13
   \   0000007E   0D6A               LDR         R5,[R1, #+32]
   \   00000080   1D42               TST         R5,R3
   \   00000082   00D0               BEQ         ??BMP085_BUS_WRITE_FUNC_14
   \   00000084   401C               ADD         R0,R0,#+1
   \                     ??BMP085_BUS_WRITE_FUNC_14:
   \   00000086   9442               CMP         R4,R2
   \   00000088   F6D3               BCC         ??BMP085_BUS_WRITE_FUNC_12
     87                  }
     88          	return error;
   \                     ??BMP085_BUS_WRITE_FUNC_13:
   \   0000008A   ....               B           ?Subroutine20
   \                     ??BMP085_BUS_WRITE_FUNC_2:
   \   0000008C   FFEFFFFF           DC32        0xffffefff
     89          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine20:
   \   00000000   F0BC               POP         {R4-R7}
   \   00000002   02BC               POP         {R1}
   \   00000004   0847               BX          R1                 ;; return
     90          
     91          //*=========================================================
     92          //*		READ
     93          //*=========================================================
     94          //*----------------------------------------------------------------------------
     95          //* \fn    AT91F_TWI_ReadByte
     96          //* \brief Read a byte from a slave device
     97          //*----------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
     98          unsigned int bmp085_t::BMP085_BUS_READ_FUNC(const AT91PS_TWI pTwi ,int mode, int int_address, unsigned char *data, unsigned int nb)
     99          {
   \                     ??BMP085_BUS_READ_FUNC:
   \   00000000   F0B5               PUSH        {R4-R7,LR}
   \   00000002   059D               LDR         R5,[SP, #+20]
   \   00000004   069E               LDR         R6,[SP, #+24]
    100          	unsigned int status,counter=0,error=0;
   \   00000006   0020               MOV         R0,#+0
   \   00000008   0024               MOV         R4,#+0
    101                  unsigned int temp=0;
    102          	// Set TWI Internal Address Register
    103          	if ((mode & AT91C_TWI_IADRSZ) != 0) pTwi->TWI_IADR = int_address;
   \   0000000A   C027               MOV         R7,#+192
   \   0000000C   BF00               LSL         R7,R7,#+2          ;; #+768
   \   0000000E   3A42               TST         R2,R7
   \   00000010   00D0               BEQ         ??BMP085_BUS_READ_FUNC_1
   \   00000012   CB60               STR         R3,[R1, #+12]
    104          
    105          	// Set the TWI Master Mode Register
    106          	pTwi->TWI_MMR = mode | AT91C_TWI_MREAD;
   \                     ??BMP085_BUS_READ_FUNC_1:
   \   00000014   8023               MOV         R3,#+128
   \   00000016   5B01               LSL         R3,R3,#+5          ;; #+4096
   \   00000018   1343               ORR         R3,R2
   \   0000001A   4B60               STR         R3,[R1, #+4]
    107          
    108          	// Start transfer
    109          	if (nb == 1){
   \   0000001C   ....               LDR         R2,??DataTable1    ;; 0x7d1
   \   0000001E   012E               CMP         R6,#+1
   \   00000020   0CD1               BNE         ??BMP085_BUS_READ_FUNC_2
    110          	   pTwi->TWI_CR = AT91C_TWI_START | AT91C_TWI_STOP;
   \   00000022   0323               MOV         R3,#+3
   \   00000024   0B60               STR         R3,[R1, #+0]
    111          	   status = pTwi->TWI_SR;
   \   00000026   0B6A               LDR         R3,[R1, #+32]
    112              	   if ((status & ERROR) == ERROR) error++;
   \   00000028   00E0               B           ??BMP085_BUS_READ_FUNC_3
    113          	   while (!(status & AT91C_TWI_TXCOMP_MASTER))
    114                     {
    115              	      status = pTwi->TWI_SR;
    116                        if ((status & ERROR) == ERROR) error++;
    117                        if(temp >2000)
    118                          {
    119                            temp=0;
    120                            break;
    121                          } 
    122                        temp ++;
   \                     ??BMP085_BUS_READ_FUNC_4:
   \   0000002A   401C               ADD         R0,R0,#+1
   \                     ??BMP085_BUS_READ_FUNC_3:
   \   0000002C   DB07               LSL         R3,R3,#+31
   \   0000002E   02D4               BMI         ??BMP085_BUS_READ_FUNC_5
   \   00000030   0B6A               LDR         R3,[R1, #+32]
   \   00000032   9042               CMP         R0,R2
   \   00000034   F9D3               BCC         ??BMP085_BUS_READ_FUNC_4
    123              	   }
    124          	   *(data) = pTwi->TWI_RHR;
   \                     ??BMP085_BUS_READ_FUNC_5:
   \   00000036   086B               LDR         R0,[R1, #+48]
   \   00000038   2870               STRB        R0,[R5, #+0]
   \   0000003A   13E0               B           ??BMP085_BUS_READ_FUNC_6
    125          	}
    126           	else{
    127           	   pTwi->TWI_CR = AT91C_TWI_START | AT91C_TWI_MSEN;
   \                     ??BMP085_BUS_READ_FUNC_2:
   \   0000003C   0523               MOV         R3,#+5
   \   0000003E   0B60               STR         R3,[R1, #+0]
    128          	   status = pTwi->TWI_SR;
   \   00000040   0B6A               LDR         R3,[R1, #+32]
    129          	   if ((status & ERROR) == ERROR) error++;
   \   00000042   0AE0               B           ??BMP085_BUS_READ_FUNC_7
    130          
    131          	// Wait transfer is finished
    132                     while (!(status & AT91C_TWI_TXCOMP_MASTER))
    133                     {
    134             		status = pTwi->TWI_SR;
    135             		if ((status & ERROR )== ERROR) error++;
    136                          if(temp >2000)
    137                          {
    138                            temp=0;
    139                            break;
    140                          } 
    141                          temp ++;
   \                     ??BMP085_BUS_READ_FUNC_8:
   \   00000044   401C               ADD         R0,R0,#+1
    142              		if(status & AT91C_TWI_RXRDY)
   \   00000046   9F07               LSL         R7,R3,#+30
   \   00000048   07D5               BPL         ??BMP085_BUS_READ_FUNC_7
    143                          {
    144          			*(data+counter++) = pTwi->TWI_RHR;
   \   0000004A   0F6B               LDR         R7,[R1, #+48]
   \   0000004C   2F55               STRB        R7,[R5, R4]
   \   0000004E   641C               ADD         R4,R4,#+1
    145          			if (counter == (nb - 1)) pTwi->TWI_CR = AT91C_TWI_STOP;
   \   00000050   771E               SUB         R7,R6,#+1
   \   00000052   BC42               CMP         R4,R7
   \   00000054   01D1               BNE         ??BMP085_BUS_READ_FUNC_7
   \   00000056   0227               MOV         R7,#+2
   \   00000058   0F60               STR         R7,[R1, #+0]
    146          		}
   \                     ??BMP085_BUS_READ_FUNC_7:
   \   0000005A   DB07               LSL         R3,R3,#+31
   \   0000005C   02D4               BMI         ??BMP085_BUS_READ_FUNC_6
   \   0000005E   0B6A               LDR         R3,[R1, #+32]
   \   00000060   9042               CMP         R0,R2
   \   00000062   EFD3               BCC         ??BMP085_BUS_READ_FUNC_8
    147          	   }
    148          	}
    149          	return 0;
   \                     ??BMP085_BUS_READ_FUNC_6:
   \   00000064   0020               MOV         R0,#+0
   \   00000066   C046               NOP         
   \   00000068                      REQUIRE ?Subroutine20
   \   00000068                      ;; // Fall through to label ?Subroutine20
    150          }
    151          
    152          
    153          
    154          
    155          
    156          
    157          /*-----------------------------------------------------------------------------
    158          / Wait function with the Periodic Interval Timer (PIT)
    159          / The wait time is from 1ms to 999ms.
    160          /----------------------------------------------------------------------------*/

   \                                 In segment CODE, align 4, keep-with-next
    161          void bmp085_t::AT91F_WaitMiliSecond (unsigned int MiliSeconds)
    162          {
    163             unsigned int PitStatus = 0;     /* Status register of the PIT */
    164             unsigned int PitLoop = 0;    /* Store the number of PIT Loop */
    165          
    166             AT91C_BASE_PITC->PITC_PIMR = AT91C_PITC_PITEN|PIT_PIV_MILI_SECOND_VALUE;
   \                     ??AT91F_WaitMiliSecond:
   \   00000000   0848               LDR         R0,??AT91F_WaitMiliSecond_1  ;; 0xfffffd30
   \   00000002   094A               LDR         R2,??AT91F_WaitMiliSecond_1+0x4  ;; 0x1000667
   \   00000004   0260               STR         R2,[R0, #+0]
    167          
    168             for( PitLoop=0; PitLoop <(MiliSeconds*3);)   /* One PIT loop equals 333ms */
   \   00000006   0020               MOV         R0,#+0
   \   00000008   06E0               B           ??AT91F_WaitMiliSecond_2
    169             {
    170              /* Wait for the PIT counter overflow occurs */
    171              while ((AT91C_BASE_PITC->PITC_PISR & AT91C_PITC_PITS)==0);
   \                     ??AT91F_WaitMiliSecond_3:
   \   0000000A   084A               LDR         R2,??AT91F_WaitMiliSecond_1+0x8  ;; 0xfffffd34
   \   0000000C   1268               LDR         R2,[R2, #+0]
   \   0000000E   D207               LSL         R2,R2,#+31
   \   00000010   FBD5               BPL         ??AT91F_WaitMiliSecond_3
    172              /* Read the PIT Interval Value Reg. to clear it for the next overflow */
    173              PitStatus = AT91C_BASE_PITC->PITC_PIVR ;
   \   00000012   074A               LDR         R2,??AT91F_WaitMiliSecond_1+0xC  ;; 0xfffffd38
   \   00000014   1268               LDR         R2,[R2, #+0]
    174              /* dummy access to avoid IAR warning */
    175              PitStatus = PitStatus ;
    176              PitLoop++;
   \   00000016   401C               ADD         R0,R0,#+1
    177             }
   \                     ??AT91F_WaitMiliSecond_2:
   \   00000018   0322               MOV         R2,#+3
   \   0000001A   4A43               MUL         R2,R1
   \   0000001C   9042               CMP         R0,R2
   \   0000001E   F4D3               BCC         ??AT91F_WaitMiliSecond_3
    178          }
   \   00000020   00B0               ADD         SP,#+0
   \   00000022   7047               BX          LR                 ;; return
   \                     ??AT91F_WaitMiliSecond_1:
   \   00000024   30FDFFFF           DC32        0xfffffd30
   \   00000028   67060001           DC32        0x1000667
   \   0000002C   34FDFFFF           DC32        0xfffffd34
   \   00000030   38FDFFFF           DC32        0xfffffd38
    179          
    180          //----------------------------------------------------------------
    181          /** initialize BMP085 / SMD500 
    182          
    183            This function initializes the BMP085 pressure sensor/ the successor SMD500 is also supported.
    184            The function automatically detects the sensor type and stores this for all future communication and calculation steps
    185            \param *bmp085_t pointer to bmp085 device data structure
    186            \return result of communication routines
    187          
    188          */
    189          

   \                                 In segment CODE, align 4, keep-with-next
    190          int bmp085_init() //(bmp085_t *bmp085) 
    191          {
   \                     ??bmp085_init:
   \   00000000   F1B5               PUSH        {R0,R4-R7,LR}
    192            char comres=0;
    193            unsigned char data;
    194          
    195            //p_bmp085 = bmp085;                                      /* assign BMP085 ptr */
    196            //p_bmp085->sensortype = E_SENSOR_NOT_DETECTED;
    197            //p_bmp085->dev_addr = BMP085_I2C_ADDR;                   /* preset BMP085 I2C_addr */
    198            comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_CHIP_ID__REG, &data, 1);  /* read Chip Id */
   \   00000002   ....               LDR         R4,??DataTable16   ;; bmp_update_flag
   \   00000004   ....               LDR         R5,??DataTable17   ;; 0xfffb8000
   \   00000006   ....               LDR         R6,??DataTable12   ;; 0x770100
   \   00000008   0120               MOV         R0,#+1
   \   0000000A   01B4               PUSH        {R0}
   \   0000000C   01A8               ADD         R0,SP,#+4
   \   0000000E   01B4               PUSH        {R0}
   \   00000010   D023               MOV         R3,#+208
   \   00000012   321C               MOV         R2,R6
   \   00000014   291C               MOV         R1,R5
   \   00000016   606B               LDR         R0,[R4, #+52]
   \   00000018   ........           BL          ??BMP085_BUS_READ_FUNC
   \   0000001C   0106               LSL         R1,R0,#+24
   \   0000001E   090E               LSR         R1,R1,#+24
    199             
    200            p_bmp085->number_of_samples = 1;  
   \   00000020   606B               LDR         R0,[R4, #+52]
   \   00000022   0122               MOV         R2,#+1
   \   00000024   0262               STR         R2,[R0, #+32]
    201            p_bmp085->oversampling_setting=2;
   \   00000026   0222               MOV         R2,#+2
   \   00000028   8284               STRH        R2,[R0, #+36]
    202          
    203            //p_bmp085->sensortype = BOSCH_PRESSURE_BMP085;
    204              
    205            comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_VERSION_REG, &data, 1); /* read Version reg */
   \   0000002A   0F1C               MOV         R7,R1
   \   0000002C   0121               MOV         R1,#+1
   \   0000002E   02B4               PUSH        {R1}
   \   00000030   03A9               ADD         R1,SP,#+12
   \   00000032   02B4               PUSH        {R1}
   \   00000034   D123               MOV         R3,#+209
   \   00000036   321C               MOV         R2,R6
   \   00000038   291C               MOV         R1,R5
   \   0000003A   ........           BL          ??BMP085_BUS_READ_FUNC
   \   0000003E   3D18               ADD         R5,R7,R0
   \   00000040   2D06               LSL         R5,R5,#+24
   \   00000042   2D0E               LSR         R5,R5,#+24
    206              
    207            p_bmp085->ml_version = BMP085_GET_BITSLICE(data, BMP085_ML_VERSION);        /* get ML Version */
   \   00000044   606B               LDR         R0,[R4, #+52]
   \   00000046   04A9               ADD         R1,SP,#+16
   \   00000048   0978               LDRB        R1,[R1, #+0]
   \   0000004A   0907               LSL         R1,R1,#+28
   \   0000004C   090F               LSR         R1,R1,#+28
   \   0000004E   C175               STRB        R1,[R0, #+23]
    208            p_bmp085->al_version = BMP085_GET_BITSLICE(data, BMP085_AL_VERSION);        /* get AL Version */
   \   00000050   606B               LDR         R0,[R4, #+52]
   \   00000052   04A9               ADD         R1,SP,#+16
   \   00000054   0978               LDRB        R1,[R1, #+0]
   \   00000056   0909               LSR         R1,R1,#+4
   \   00000058   0176               STRB        R1,[R0, #+24]
    209            bmp085_get_cal_param( ); /* readout bmp085 calibparam structure */
   \   0000005A   ........           BL          ??bmp085_get_cal_param
    210          
    211            return comres;
   \   0000005E   281C               MOV         R0,R5
   \   00000060   05B0               ADD         SP,#+20
   \   00000062   ....               B           ?Subroutine20
    212          
    213          }
    214          
    215          /** read out parameters cal_param from BMP085 memory
    216             \return result of communication routines
    217          */
    218          
    219          //int bmp085_read_cal_param(void)

   \                                 In segment CODE, align 4, keep-with-next
    220          int bmp085_get_cal_param(void)
    221          {
   \                     ??bmp085_get_cal_param:
   \   00000000   10B5               PUSH        {R4,LR}
   \   00000002   86B0               SUB         SP,#+24
    222            int comres;
    223            unsigned char data[22];
    224            comres = p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_PROM_START__ADDR, data, BMP085_PROM_DATA__LEN);
   \   00000004   ....               LDR         R4,??DataTable16   ;; bmp_update_flag
   \   00000006   1620               MOV         R0,#+22
   \   00000008   01B4               PUSH        {R0}
   \   0000000A   01A8               ADD         R0,SP,#+4
   \   0000000C   01B4               PUSH        {R0}
   \   0000000E   AA23               MOV         R3,#+170
   \   00000010   ....               LDR         R2,??DataTable12   ;; 0x770100
   \   00000012   ....               LDR         R1,??DataTable17   ;; 0xfffb8000
   \   00000014   606B               LDR         R0,[R4, #+52]
   \   00000016   ........           BL          ??BMP085_BUS_READ_FUNC
    225            
    226            /*parameters AC1-AC6*/
    227            p_bmp085->cal_param.ac1 =  (data[0] <<8) | data[1];
   \   0000001A   616B               LDR         R1,[R4, #+52]
   \   0000001C   02AA               ADD         R2,SP,#+8
   \   0000001E   1278               LDRB        R2,[R2, #+0]
   \   00000020   1202               LSL         R2,R2,#+8
   \   00000022   02AB               ADD         R3,SP,#+8
   \   00000024   5B78               LDRB        R3,[R3, #+1]
   \   00000026   1343               ORR         R3,R2
   \   00000028   0B80               STRH        R3,[R1, #+0]
    228            p_bmp085->cal_param.ac2 =  (data[2] <<8) | data[3];
   \   0000002A   02AA               ADD         R2,SP,#+8
   \   0000002C   9278               LDRB        R2,[R2, #+2]
   \   0000002E   1202               LSL         R2,R2,#+8
   \   00000030   02AB               ADD         R3,SP,#+8
   \   00000032   DB78               LDRB        R3,[R3, #+3]
   \   00000034   1343               ORR         R3,R2
   \   00000036   4B80               STRH        R3,[R1, #+2]
    229            p_bmp085->cal_param.ac3 =  (data[4] <<8) | data[5];
   \   00000038   02AA               ADD         R2,SP,#+8
   \   0000003A   1279               LDRB        R2,[R2, #+4]
   \   0000003C   1202               LSL         R2,R2,#+8
   \   0000003E   02AB               ADD         R3,SP,#+8
   \   00000040   5B79               LDRB        R3,[R3, #+5]
   \   00000042   1343               ORR         R3,R2
   \   00000044   8B80               STRH        R3,[R1, #+4]
    230            p_bmp085->cal_param.ac4 =  (data[6] <<8) | data[7];
   \   00000046   02AA               ADD         R2,SP,#+8
   \   00000048   9279               LDRB        R2,[R2, #+6]
   \   0000004A   1202               LSL         R2,R2,#+8
   \   0000004C   02AB               ADD         R3,SP,#+8
   \   0000004E   DB79               LDRB        R3,[R3, #+7]
   \   00000050   1343               ORR         R3,R2
   \   00000052   CB80               STRH        R3,[R1, #+6]
    231            p_bmp085->cal_param.ac5 =  (data[8] <<8) | data[9];
   \   00000054   02AA               ADD         R2,SP,#+8
   \   00000056   127A               LDRB        R2,[R2, #+8]
   \   00000058   1202               LSL         R2,R2,#+8
   \   0000005A   02AB               ADD         R3,SP,#+8
   \   0000005C   5B7A               LDRB        R3,[R3, #+9]
   \   0000005E   1343               ORR         R3,R2
   \   00000060   0B81               STRH        R3,[R1, #+8]
    232            p_bmp085->cal_param.ac6 =  (data[10] <<8) | data[11];
   \   00000062   02AA               ADD         R2,SP,#+8
   \   00000064   927A               LDRB        R2,[R2, #+10]
   \   00000066   1202               LSL         R2,R2,#+8
   \   00000068   02AB               ADD         R3,SP,#+8
   \   0000006A   DB7A               LDRB        R3,[R3, #+11]
   \   0000006C   1343               ORR         R3,R2
   \   0000006E   4B81               STRH        R3,[R1, #+10]
    233            
    234            /*parameters B1,B2*/
    235            p_bmp085->cal_param.b1 =  (data[12] <<8) | data[13];
   \   00000070   02AA               ADD         R2,SP,#+8
   \   00000072   127B               LDRB        R2,[R2, #+12]
   \   00000074   1202               LSL         R2,R2,#+8
   \   00000076   02AB               ADD         R3,SP,#+8
   \   00000078   5B7B               LDRB        R3,[R3, #+13]
   \   0000007A   1343               ORR         R3,R2
   \   0000007C   8B81               STRH        R3,[R1, #+12]
    236            p_bmp085->cal_param.b2 =  (data[14] <<8) | data[15];
   \   0000007E   02AA               ADD         R2,SP,#+8
   \   00000080   927B               LDRB        R2,[R2, #+14]
   \   00000082   1202               LSL         R2,R2,#+8
   \   00000084   02AB               ADD         R3,SP,#+8
   \   00000086   DB7B               LDRB        R3,[R3, #+15]
   \   00000088   1343               ORR         R3,R2
   \   0000008A   CB81               STRH        R3,[R1, #+14]
    237            
    238            /*parameters MB,MC,MD*/
    239            p_bmp085->cal_param.mb =  (data[16] <<8) | data[17];
   \   0000008C   02AA               ADD         R2,SP,#+8
   \   0000008E   127C               LDRB        R2,[R2, #+16]
   \   00000090   1202               LSL         R2,R2,#+8
   \   00000092   02AB               ADD         R3,SP,#+8
   \   00000094   5B7C               LDRB        R3,[R3, #+17]
   \   00000096   1343               ORR         R3,R2
   \   00000098   0B82               STRH        R3,[R1, #+16]
    240            p_bmp085->cal_param.mc =  (data[18] <<8) | data[19];
   \   0000009A   02AA               ADD         R2,SP,#+8
   \   0000009C   927C               LDRB        R2,[R2, #+18]
   \   0000009E   1202               LSL         R2,R2,#+8
   \   000000A0   02AB               ADD         R3,SP,#+8
   \   000000A2   DB7C               LDRB        R3,[R3, #+19]
   \   000000A4   1343               ORR         R3,R2
   \   000000A6   4B82               STRH        R3,[R1, #+18]
    241            p_bmp085->cal_param.md =  (data[20] <<8) | data[21];
   \   000000A8   02AA               ADD         R2,SP,#+8
   \   000000AA   127D               LDRB        R2,[R2, #+20]
   \   000000AC   1202               LSL         R2,R2,#+8
   \   000000AE   02AB               ADD         R3,SP,#+8
   \   000000B0   5B7D               LDRB        R3,[R3, #+21]
   \   000000B2   1343               ORR         R3,R2
   \   000000B4   8B82               STRH        R3,[R1, #+20]
    242            
    243            return comres;  
   \   000000B6   08B0               ADD         SP,#+32
   \   000000B8   ....               B           ?Subroutine21
    244            
    245          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine21:
   \   00000000   10BC               POP         {R4}
   \   00000002   02BC               POP         {R1}
   \   00000004   0847               BX          R1                 ;; return
    246          
    247          
    248          /** calculate temperature from ut
    249            ut was read from the device via I2C and fed into the right calc path for either SMD500 or BMP085
    250            \param ut parameter ut read from device
    251            \return temperature in steps of 0.1 deg celsius
    252            \see bmp085_read_ut()
    253          */
    254          
    255          //short bmp085_calc_temperature(unsigned long ut) 

   \                                 In segment CODE, align 4, keep-with-next
    256          short bmp085_get_temperature(unsigned long ut) 
    257          {
   \                     ??bmp085_get_temperature:
   \   00000000   10B5               PUSH        {R4,LR}
    258            //short temperature;
    259            long x1,x2;    
    260          
    261            x1 = (((long) ut - (long) p_bmp085->cal_param.ac6) * (long) p_bmp085->cal_param.ac5) >> 15;
   \   00000002   ....               LDR         R2,??DataTable16   ;; bmp_update_flag
   \   00000004   536B               LDR         R3,[R2, #+52]
   \   00000006   5989               LDRH        R1,[R3, #+10]
   \   00000008   401A               SUB         R0,R0,R1
   \   0000000A   1989               LDRH        R1,[R3, #+8]
   \   0000000C   4843               MUL         R0,R1
   \   0000000E   C413               ASR         R4,R0,#+15
    262            x2 = ((long) p_bmp085->cal_param.mc << 11) / (x1 + p_bmp085->cal_param.md);
    263            p_bmp085->param_b5 = x1 + x2;
   \   00000010   1220               MOV         R0,#+18
   \   00000012   185E               LDRSH       R0,[R3, R0]
   \   00000014   C002               LSL         R0,R0,#+11
   \   00000016   1421               MOV         R1,#+20
   \   00000018   595E               LDRSH       R1,[R3, R1]
   \   0000001A   6118               ADD         R1,R4,R1
   \   0000001C   ........           _BLF        ??div32_t,??rT??div32_t
   \   00000020   6018               ADD         R0,R4,R1
   \   00000022   D861               STR         R0,[R3, #+28]
    264          
    265          
    266            temperature = ((p_bmp085->param_b5 + 8) >> 4);  // temperature in 0.1ฐC
   \   00000024   0830               ADD         R0,#+8
   \   00000026   0011               ASR         R0,R0,#+4
   \   00000028   1081               STRH        R0,[R2, #+8]
    267          
    268            return (temperature);
   \   0000002A   0820               MOV         R0,#+8
   \   0000002C   105E               LDRSH       R0,[R2, R0]
   \   0000002E   C046               NOP         
   \   00000030                      REQUIRE ?Subroutine21
   \   00000030                      ;; // Fall through to label ?Subroutine21
    269          }
    270          
    271          /** calculate pressure from up
    272            up was read from the device via I2C and fed into the right calc path for either SMD500 or BMP085
    273            In case of SMD500 value averaging is done in this function, in case of BMP085 averaging is done through oversampling by the sensor IC
    274          
    275            \param ut parameter ut read from device
    276            \return temperature in steps of 1.0 Pa
    277            \see bmp085_read_up()
    278          */
    279          
    280          //long bmp085_calc_pressure(unsigned long up)

   \                                 In segment CODE, align 4, keep-with-next
    281          long bmp085_get_pressure(unsigned long up)
    282          {
   \                     ??bmp085_get_pressure:
   \   00000000   F0B5               PUSH        {R4-R7,LR}
   \   00000002   061C               MOV         R6,R0
    283             long x1,x2,x3,b3,b6;
    284             unsigned long b4, b7;
    285             
    286             b6 = p_bmp085->param_b5 - 4000;
   \   00000004   ....               LDR         R2,??DataTable16   ;; bmp_update_flag
   \   00000006   536B               LDR         R3,[R2, #+52]
   \   00000008   D869               LDR         R0,[R3, #+28]
   \   0000000A   2549               LDR         R1,??bmp085_get_pressure_1  ;; 0xfffff060
   \   0000000C   4418               ADD         R4,R0,R1
    287             //*****calculate B3************
    288             x1 = (b6*b6) >> 12;	 	 
    289             x1 *= p_bmp085->cal_param.b2;
    290             x1 >>=11;
    291          
    292             x2 = (p_bmp085->cal_param.ac2*b6);
    293             x2 >>=11;
    294          
    295             x3 = x1 +x2;
    296          
    297             b3 = (((((long)p_bmp085->cal_param.ac1 )*4 + x3) <<p_bmp085->oversampling_setting) + 2) >> 2;
    298          
    299             //*****calculate B4************
    300             x1 = (p_bmp085->cal_param.ac3* b6) >> 13;
    301             x2 = (p_bmp085->cal_param.b1 * ((b6*b6) >> 12) ) >> 16;
    302             x3 = ((x1 + x2) + 2) >> 2;
    303             b4 = (p_bmp085->cal_param.ac4 * (unsigned long) (x3 + 32768)) >> 15;
   \   0000000E   201C               MOV         R0,R4
   \   00000010   6043               MUL         R0,R4
   \   00000012   0013               ASR         R0,R0,#+12
   \   00000014   D988               LDRH        R1,[R3, #+6]
   \   00000016   0425               MOV         R5,#+4
   \   00000018   5D5F               LDRSH       R5,[R3, R5]
   \   0000001A   6543               MUL         R5,R4
   \   0000001C   6D13               ASR         R5,R5,#+13
   \   0000001E   0C27               MOV         R7,#+12
   \   00000020   DF5F               LDRSH       R7,[R3, R7]
   \   00000022   4743               MUL         R7,R0
   \   00000024   3F14               ASR         R7,R7,#+16
   \   00000026   ED19               ADD         R5,R5,R7
   \   00000028   AD1C               ADD         R5,R5,#+2
   \   0000002A   AD10               ASR         R5,R5,#+2
   \   0000002C   8027               MOV         R7,#+128
   \   0000002E   3F02               LSL         R7,R7,#+8          ;; #+32768
   \   00000030   ED19               ADD         R5,R5,R7
   \   00000032   6943               MUL         R1,R5
   \   00000034   C90B               LSR         R1,R1,#+15
    304               
    305             b7 = ((unsigned long)(up - b3) * (50000>>p_bmp085->oversampling_setting));   
   \   00000036   2425               MOV         R5,#+36
   \   00000038   5D5F               LDRSH       R5,[R3, R5]
   \   0000003A   B446               MOV         R12,R6
   \   0000003C   0026               MOV         R6,#+0
   \   0000003E   9E5F               LDRSH       R6,[R3, R6]
   \   00000040   B700               LSL         R7,R6,#+2
   \   00000042   0E26               MOV         R6,#+14
   \   00000044   9E5F               LDRSH       R6,[R3, R6]
   \   00000046   7043               MUL         R0,R6
   \   00000048   C012               ASR         R0,R0,#+11
   \   0000004A   3818               ADD         R0,R7,R0
   \   0000004C   0226               MOV         R6,#+2
   \   0000004E   9B5F               LDRSH       R3,[R3, R6]
   \   00000050   6343               MUL         R3,R4
   \   00000052   DB12               ASR         R3,R3,#+11
   \   00000054   C018               ADD         R0,R0,R3
   \   00000056   A840               LSL         R0,R5
   \   00000058   801C               ADD         R0,R0,#+2
   \   0000005A   8010               ASR         R0,R0,#+2
   \   0000005C   6646               MOV         R6,R12
   \   0000005E   301A               SUB         R0,R6,R0
   \   00000060   104B               LDR         R3,??bmp085_get_pressure_1+0x4  ;; 0xc350
   \   00000062   2B41               ASR         R3,R5
   \   00000064   5843               MUL         R0,R3
    306             if (b7 < 0x80000000)
   \   00000066   8023               MOV         R3,#+128
   \   00000068   1B06               LSL         R3,R3,#+24         ;; #-2147483648
   \   0000006A   9842               CMP         R0,R3
   \   0000006C   03D2               BCS         ??bmp085_get_pressure_2
    307             {
    308               pressure = (b7 << 1) / b4;
   \   0000006E   4000               LSL         R0,R0,#+1
   \   00000070   ........           _BLF        ??divu32_t,??rT??divu32_t
   \   00000074   02E0               B           ??bmp085_get_pressure_3
    309             }
    310             else
    311             { 
    312               pressure = (b7 / b4) << 1;
   \                     ??bmp085_get_pressure_2:
   \   00000076   ........           _BLF        ??divu32_t,??rT??divu32_t
   \   0000007A   4900               LSL         R1,R1,#+1
    313             }
    314             
    315             x1 = pressure >> 8;
   \                     ??bmp085_get_pressure_3:
   \   0000007C   0812               ASR         R0,R1,#+8
    316             x1 *= x1;
    317             x1 = (x1 * 3038) >> 16;
    318             x2 = (pressure * (-7357)) >> 16;
    319             pressure += (x1 + x2 + 3791) >> 4;	// pressure in Pa  
   \   0000007E   031C               MOV         R3,R0
   \   00000080   4343               MUL         R3,R0
   \   00000082   0948               LDR         R0,??bmp085_get_pressure_1+0x8  ;; 0xbde
   \   00000084   4343               MUL         R3,R0
   \   00000086   1814               ASR         R0,R3,#+16
   \   00000088   084B               LDR         R3,??bmp085_get_pressure_1+0xC  ;; 0xffffe343
   \   0000008A   0C1C               MOV         R4,R1
   \   0000008C   5C43               MUL         R4,R3
   \   0000008E   2314               ASR         R3,R4,#+16
   \   00000090   C018               ADD         R0,R0,R3
   \   00000092   074B               LDR         R3,??bmp085_get_pressure_1+0x10  ;; 0xecf
   \   00000094   C018               ADD         R0,R0,R3
   \   00000096   0011               ASR         R0,R0,#+4
   \   00000098   0818               ADD         R0,R1,R0
   \   0000009A   9064               STR         R0,[R2, #+72]
    320          
    321             return (pressure);
   \   0000009C   ....               B           ?Subroutine20
   \   0000009E   C046               NOP         
   \                     ??bmp085_get_pressure_1:
   \   000000A0   60F0FFFF           DC32        0xfffff060
   \   000000A4   50C30000           DC32        0xc350
   \   000000A8   DE0B0000           DC32        0xbde
   \   000000AC   43E3FFFF           DC32        0xffffe343
   \   000000B0   CF0E0000           DC32        0xecf
    322          }
    323          
    324          
    325          /** read out ut for temperature conversion
    326             \return ut parameter that represents the uncompensated temperature sensors conversion value
    327          */
    328          
    329          //unsigned short bmp085_read_ut ()

   \                                 In segment CODE, align 4, keep-with-next
    330          unsigned short bmp085_get_ut ()
    331          {
   \                     ??bmp085_get_ut:
   \   00000000   71B5               PUSH        {R0,R4-R6,LR}
    332            unsigned char data[2];    
    333            unsigned char ctrl_reg_data;
    334            int wait_time;
    335            int comres;
    336           
    337            ctrl_reg_data = BMP085_T_MEASURE;
   \   00000002   6846               MOV         R0,SP
   \   00000004   2E21               MOV         R1,#+46
   \   00000006   8170               STRB        R1,[R0, #+2]
    338            wait_time = BMP085_TEMP_CONVERSION_TIME;
    339            
    340            comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, BMP085_CTRL_MEAS_REG, &ctrl_reg_data, 1);
   \   00000008   ....               LDR         R4,??DataTable16   ;; bmp_update_flag
   \   0000000A   ....               LDR         R5,??DataTable17   ;; 0xfffb8000
   \   0000000C   ....               LDR         R6,??DataTable12   ;; 0x770100
   \   0000000E   0120               MOV         R0,#+1
   \   00000010   01B4               PUSH        {R0}
   \   00000012   01A8               ADD         R0,SP,#+4
   \   00000014   801C               ADD         R0,R0,#+2
   \   00000016   01B4               PUSH        {R0}
   \   00000018   F423               MOV         R3,#+244
   \   0000001A   321C               MOV         R2,R6
   \   0000001C   291C               MOV         R1,R5
   \   0000001E   606B               LDR         R0,[R4, #+52]
   \   00000020   ........           BL          ??BMP085_BUS_WRITE_FUNC
    341            
    342           p_bmp085->AT91F_WaitMiliSecond (wait_time);  
   \   00000024   0521               MOV         R1,#+5
   \   00000026   606B               LDR         R0,[R4, #+52]
   \   00000028   ........           BL          ??AT91F_WaitMiliSecond
    343            comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_ADC_OUT_MSB_REG, data, 2);
   \   0000002C   0220               MOV         R0,#+2
   \   0000002E   01B4               PUSH        {R0}
   \   00000030   03A8               ADD         R0,SP,#+12
   \   00000032   01B4               PUSH        {R0}
   \   00000034   F623               MOV         R3,#+246
   \   00000036   321C               MOV         R2,R6
   \   00000038   291C               MOV         R1,R5
   \   0000003A   606B               LDR         R0,[R4, #+52]
   \   0000003C   ........           BL          ??BMP085_BUS_READ_FUNC
    344            ut = ((long)data[0] <<8) | data[1];
   \   00000040   04A8               ADD         R0,SP,#+16
   \   00000042   0078               LDRB        R0,[R0, #+0]
   \   00000044   0002               LSL         R0,R0,#+8
   \   00000046   04A9               ADD         R1,SP,#+16
   \   00000048   4978               LDRB        R1,[R1, #+1]
   \   0000004A   0143               ORR         R1,R0
   \   0000004C   6164               STR         R1,[R4, #+68]
    345            return (ut);
   \   0000004E   0804               LSL         R0,R1,#+16
   \   00000050   000C               LSR         R0,R0,#+16
   \   00000052   05B0               ADD         SP,#+20
   \   00000054   ....               B           ?Subroutine22
    346            
    347          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine22:
   \   00000000   70BC               POP         {R4-R6}
   \   00000002   02BC               POP         {R1}
   \   00000004   0847               BX          R1                 ;; return
    348          
    349          //----------------------------------------------------------------
    350          /** initialize SCP1000D11
    351          
    352            This function initializes the BMP085 pressure sensor/ the successor SMD500 is also supported.
    353            The function automatically detects the sensor type and stores this for all future communication and calculation steps
    354            \param *bmp085_t pointer to bmp085 device data structure
    355            \return result of communication routines
    356          
    357          */

   \                                 In segment CODE, align 4, keep-with-next
    358          unsigned int scp1000_init(void)
    359          {
   \                     ??scp1000_init:
   \   00000000   71B5               PUSH        {R0,R4-R6,LR}
    360            unsigned int comres=0;
    361            unsigned char cle_reg_data = High_speed;
   \   00000002   6846               MOV         R0,SP
   \   00000004   0921               MOV         R1,#+9
   \   00000006   0170               STRB        R1,[R0, #+0]
   \   00000008   ....               LDR         R5,??DataTable17   ;; 0xfffb8000
   \   0000000A   ....               LDR         R6,??DataTable18   ;; 0x110100
   \   0000000C   ....               LDR         R4,??DataTable16   ;; bmp_update_flag
    362            //unsigned char cle_reg_data1 = 0x00;
    363            //unsigned char cle_reg_data1 = 0x14;
    364            //comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,SPC1000AddrW | AT91C_TWI_IADRSZ_1_BYTE, OPERATION, &cle_reg_data1, 1);
    365              comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, STATUS,&scp_status, 1);
    366            while(scp_status & 0x01)//ศทถจฝ๘ศ๋standbyฤฃสฝ
    367            {
    368              comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, STATUS,&scp_status, 1);
   \                     ??scp1000_init_1:
   \   0000000E   0120               MOV         R0,#+1
   \   00000010   01B4               PUSH        {R0}
   \   00000012   A01D               ADD         R0,R4,#+6
   \   00000014   01B4               PUSH        {R0}
   \   00000016   0723               MOV         R3,#+7
   \   00000018   321C               MOV         R2,R6
   \   0000001A   291C               MOV         R1,R5
   \   0000001C   606B               LDR         R0,[R4, #+52]
   \   0000001E   ........           BL          ??BMP085_BUS_READ_FUNC
    369            }
   \   00000022   A079               LDRB        R0,[R4, #+6]
   \   00000024   02B0               ADD         SP,#+8
   \   00000026   C007               LSL         R0,R0,#+31
   \   00000028   F1D4               BMI         ??scp1000_init_1
    370             if(scp_status & 0x20 != 0)//ะดศ๋ฤฃสฝสฑศทศฯDRDYรปึรฮปฃฌำะิ๒ถมศกฦ๘ันสึตศฅณ
    371            {
    372                scp1000_pressure(&scp_pressure);
    373            }
    374            comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,SPC1000AddrW | AT91C_TWI_IADRSZ_1_BYTE, OPERATION, &cle_reg_data, 1);//ะดศ๋ฤฃสฝ
   \   0000002A   0120               MOV         R0,#+1
   \   0000002C   01B4               PUSH        {R0}
   \   0000002E   01A8               ADD         R0,SP,#+4
   \   00000030   01B4               PUSH        {R0}
   \   00000032   0323               MOV         R3,#+3
   \   00000034   321C               MOV         R2,R6
   \   00000036   291C               MOV         R1,R5
   \   00000038   606B               LDR         R0,[R4, #+52]
   \   0000003A   ........           BL          ??BMP085_BUS_WRITE_FUNC
   \   0000003E   051C               MOV         R5,R0
    375            //comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,HMC5843_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, HMC5843_CONFIGUREA_ADDR, &cle_reg_data1, 1);
    376            //comres += p_bmp085->BMP085_BUS_WRITE_FUNC(HMC5843_I2C_ADDR_write, HMC5843_MODE_ADDR,AT91C_TWI_IADRSZ_1_BYTE,&cle_reg_data);
    377            while(scp_status & 0x20 == 0)
    378            {
    379               comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, STATUS,&scp_status, 1);   
    380            }
    381               scp1000_pressure(&scp_pressure);
   \   00000040   2C34               ADD         R4,#+44
   \   00000042   201C               MOV         R0,R4
   \   00000044   ........           BL          ??scp1000_pressure
    382             /*comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, OPSTATUS,&scp_opstatus, 1);
    383            while(scp_opstatus & 0x01)
    384            {
    385              comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, OPSTATUS,&scp_opstatus, 1);
    386              flag = 1;
    387            }*/
    388            return comres;
   \   00000048   281C               MOV         R0,R5
   \   0000004A   7EBC               POP         {R1-R6}
   \   0000004C   02BC               POP         {R1}
   \   0000004E   0847               BX          R1                 ;; return
    389          }
    390          

   \                                 In segment CODE, align 4, keep-with-next
    391          unsigned int scp1000_pressure(double *p)
    392          {
   \                     ??scp1000_pressure:
   \   00000000   F1B5               PUSH        {R0,R4-R7,LR}
   \   00000002   041C               MOV         R4,R0
    393              
    394            unsigned  int comres=0;
    395            unsigned char mPress[3];
    396            unsigned int m1=0;
    397            unsigned long m2=0;
    398              //float m3=0;
    399          
    400             comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, DATARD8,mPress, 1); //ป๑ศกฦ๘ันสพธ฿ืึฝฺฃบ3ฮป
   \   00000004   ....               LDR         R5,??DataTable16   ;; bmp_update_flag
   \   00000006   ....               LDR         R6,??DataTable17   ;; 0xfffb8000
   \   00000008   ....               LDR         R7,??DataTable18   ;; 0x110100
   \   0000000A   0120               MOV         R0,#+1
   \   0000000C   01B4               PUSH        {R0}
   \   0000000E   01A8               ADD         R0,SP,#+4
   \   00000010   01B4               PUSH        {R0}
   \   00000012   7F23               MOV         R3,#+127
   \   00000014   3A1C               MOV         R2,R7
   \   00000016   311C               MOV         R1,R6
   \   00000018   686B               LDR         R0,[R5, #+52]
   \   0000001A   ........           BL          ??BMP085_BUS_READ_FUNC
    401             comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, DATARD16,mPress+1, 2);//ป๑ศกฦ๘ันสพึะ & ตอืึฝฺ 
   \   0000001E   01B4               PUSH        {R0}
   \   00000020   0220               MOV         R0,#+2
   \   00000022   01B4               PUSH        {R0}
   \   00000024   04A8               ADD         R0,SP,#+16
   \   00000026   401C               ADD         R0,R0,#+1
   \   00000028   01B4               PUSH        {R0}
   \   0000002A   8023               MOV         R3,#+128
   \   0000002C   3A1C               MOV         R2,R7
   \   0000002E   311C               MOV         R1,R6
   \   00000030   686B               LDR         R0,[R5, #+52]
   \   00000032   ........           BL          ??BMP085_BUS_READ_FUNC
   \   00000036   011C               MOV         R1,R0
   \   00000038   02B0               ADD         SP,#+8
   \   0000003A   01BC               POP         {R0}
   \   0000003C   4518               ADD         R5,R0,R1
    402          
    403              *p = 0;
   \   0000003E   0020               MOV         R0,#+0
   \   00000040   0021               MOV         R1,#+0
   \   00000042   03C4               STMIA       R4!,{R0,R1}
   \   00000044   083C               SUB         R4,#+8
    404              
    405              m2 = (unsigned long)(mPress[0] & 0x07);
    406              m2 = m2<<16;
    407              m1=(mPress[1] << 8) + mPress[2];
    408              m2|=(unsigned long)m1;
    409              *p=m2/4;
   \   00000046   02A8               ADD         R0,SP,#+8
   \   00000048   0078               LDRB        R0,[R0, #+0]
   \   0000004A   4007               LSL         R0,R0,#+29
   \   0000004C   400F               LSR         R0,R0,#+29
   \   0000004E   0004               LSL         R0,R0,#+16
   \   00000050   02A9               ADD         R1,SP,#+8
   \   00000052   4978               LDRB        R1,[R1, #+1]
   \   00000054   0902               LSL         R1,R1,#+8
   \   00000056   02AA               ADD         R2,SP,#+8
   \   00000058   9278               LDRB        R2,[R2, #+2]
   \   0000005A   8918               ADD         R1,R1,R2
   \   0000005C   0143               ORR         R1,R0
   \   0000005E   8808               LSR         R0,R1,#+2
   \   00000060   ........           _BLF        __ulongToDouble,??__ulongToDouble??rT
   \   00000064   03C4               STMIA       R4!,{R0,R1}
    410              //*pPress = (((mPress[0] & 0x07)<< 16)+(mPress[1] << 8) + mPress[2])/4;
    411           //mTemperature[0]=0x27;
    412           //mTemperature[1]=0x27;
    413              return comres;
   \   00000066   281C               MOV         R0,R5
   \   00000068   FEBC               POP         {R1-R7}
   \   0000006A   02BC               POP         {R1}
   \   0000006C   0847               BX          R1                 ;; return
    414          }
    415          

   \                                 In segment CODE, align 4, keep-with-next
    416          void lidar_lite_update(double *distance)
    417          { 
   \                     ??lidar_lite_update:
   \   00000000   11B5               PUSH        {R0,R4,LR}
   \   00000002   041C               MOV         R4,R0
    418            unsigned char temp[2];
    419            p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,(0x40<<16)|AT91C_TWI_IADRSZ_NO,0,temp, 2);//ป๑ศกฦ๘ันสพึะ & ตอืึฝฺ 
   \   00000004   0220               MOV         R0,#+2
   \   00000006   01B4               PUSH        {R0}
   \   00000008   01A8               ADD         R0,SP,#+4
   \   0000000A   01B4               PUSH        {R0}
   \   0000000C   0023               MOV         R3,#+0
   \   0000000E   8022               MOV         R2,#+128
   \   00000010   D203               LSL         R2,R2,#+15         ;; #+4194304
   \   00000012   ....               LDR         R1,??DataTable28   ;; 0xfffb8000
   \   00000014   ....               LDR         R0,??DataTable29   ;; bmp_update_flag + 52
   \   00000016   0068               LDR         R0,[R0, #+0]
   \   00000018   ........           BL          ??BMP085_BUS_READ_FUNC
    420            *distance = -(temp[0]*256 + temp[1])*0.001;
   \   0000001C   02A8               ADD         R0,SP,#+8
   \   0000001E   0078               LDRB        R0,[R0, #+0]
   \   00000020   0002               LSL         R0,R0,#+8
   \   00000022   02A9               ADD         R1,SP,#+8
   \   00000024   4978               LDRB        R1,[R1, #+1]
   \   00000026   4118               ADD         R1,R0,R1
   \   00000028   4842               NEG         R0,R1
   \   0000002A   ........           _BLF        __longToDouble,??__longToDouble??rT
   \   0000002E   044A               LDR         R2,??lidar_lite_update_1  ;; 0xd2f1a9fc
   \   00000030   044B               LDR         R3,??lidar_lite_update_1+0x4  ;; 0x3f50624d
   \   00000032   ........           _BLF        __dMul,??__dMul??rT
   \   00000036   03C4               STMIA       R4!,{R0,R1}
    421          }
   \   00000038   1EBC               POP         {R1-R4}
   \   0000003A   01BC               POP         {R0}
   \   0000003C   0047               BX          R0                 ;; return
   \   0000003E   C046               NOP         
   \                     ??lidar_lite_update_1:
   \   00000040   FCA9F1D2           DC32        0xd2f1a9fc
   \   00000044   4D62503F           DC32        0x3f50624d
    422          
    423          

   \                                 In segment CODE, align 4, keep-with-next
    424          double height_average_filter(double temp2)//ฦ๘ันผฦธ฿ถศฦฝพ๙ึตยหฒจ
    425          {
   \                     ??height_average_filter:
   \   00000000   F3B5               PUSH        {R0,R1,R4-R7,LR}
   \   00000002   82B0               SUB         SP,#+8
    426              static double bmp_h_window[7];
    427              double bmp_sum_h = 0;
   \   00000004   0022               MOV         R2,#+0
   \   00000006   0023               MOV         R3,#+0
    428              static int bmp_length = 1;
    429              double bmp_height_filter;
    430              for(char i=1; i<7; i++) //for sum_e and e_window
   \   00000008   0124               MOV         R4,#+1
   \   0000000A   1D4E               LDR         R6,??height_average_filter_1  ;; ??bmp_h_window
    431              {
    432              	bmp_sum_h += bmp_h_window[i];
   \                     ??height_average_filter_2:
   \   0000000C   E500               LSL         R5,R4,#+3
   \   0000000E   6F46               MOV         R7,SP
   \   00000010   7019               ADD         R0,R6,R5
   \   00000012   03C8               LDMIA       R0!,{R0,R1}
   \   00000014   03C7               STMIA       R7!,{R0,R1}
   \   00000016   6846               MOV         R0,SP
   \   00000018   03C8               LDMIA       R0!,{R0,R1}
   \   0000001A   ........           _BLF        __dAdd,??__dAdd??rT
   \   0000001E   021C               MOV         R2,R0
   \   00000020   0B1C               MOV         R3,R1
    433                  bmp_h_window[i-1] = bmp_h_window[i];
   \   00000022   301C               MOV         R0,R6
   \   00000024   0838               SUB         R0,#+8
   \   00000026   4519               ADD         R5,R0,R5
   \   00000028   6846               MOV         R0,SP
   \   0000002A   03C8               LDMIA       R0!,{R0,R1}
   \   0000002C   03C5               STMIA       R5!,{R0,R1}
    434              }
   \   0000002E   641C               ADD         R4,R4,#+1
   \   00000030   2006               LSL         R0,R4,#+24
   \   00000032   000E               LSR         R0,R0,#+24
   \   00000034   0728               CMP         R0,#+7
   \   00000036   E9D3               BCC         ??height_average_filter_2
    435          	 //   e_window[8-1]=e_speed;sum_e += e_speed;
    436                 bmp_h_window[7-1]=temp2;
   \   00000038   3036               ADD         R6,#+48
   \   0000003A   351C               MOV         R5,R6
   \   0000003C   02A8               ADD         R0,SP,#+8
   \   0000003E   03C8               LDMIA       R0!,{R0,R1}
   \   00000040   03C5               STMIA       R5!,{R0,R1}
   \   00000042   083D               SUB         R5,#+8
    437                 bmp_sum_h += temp2;
    438                 bmp_height_filter = bmp_sum_h/bmp_length;
   \   00000044   AC68               LDR         R4,[R5, #+8]
   \   00000046   6E46               MOV         R6,SP
   \   00000048   40B4               PUSH        {R6}
   \   0000004A   03A8               ADD         R0,SP,#+12
   \   0000004C   03C8               LDMIA       R0!,{R0,R1}
   \   0000004E   ........           _BLF        __dAdd,??__dAdd??rT
   \   00000052   061C               MOV         R6,R0
   \   00000054   0F1C               MOV         R7,R1
   \   00000056   201C               MOV         R0,R4
   \   00000058   ........           _BLF        __longToDouble,??__longToDouble??rT
   \   0000005C   021C               MOV         R2,R0
   \   0000005E   0B1C               MOV         R3,R1
   \   00000060   301C               MOV         R0,R6
   \   00000062   391C               MOV         R1,R7
   \   00000064   ........           _BLF        __dDiv,??__dDiv??rT
   \   00000068   40BC               POP         {R6}
   \   0000006A   03C6               STMIA       R6!,{R0,R1}
    439                 
    440                if(bmp_length >= 7)//for length ,max = N
   \   0000006C   072C               CMP         R4,#+7
   \   0000006E   01DB               BLT         ??height_average_filter_3
    441                   bmp_length = 7;
   \   00000070   0724               MOV         R4,#+7
   \   00000072   00E0               B           ??height_average_filter_4
    442                else bmp_length++;
   \                     ??height_average_filter_3:
   \   00000074   641C               ADD         R4,R4,#+1
   \                     ??height_average_filter_4:
   \   00000076   AC60               STR         R4,[R5, #+8]
    443                
    444               return bmp_height_filter;
   \   00000078   6846               MOV         R0,SP
   \   0000007A   03C8               LDMIA       R0!,{R0,R1}
   \   0000007C   04B0               ADD         SP,#+16
   \   0000007E   ....               B           ?Subroutine23
   \                     ??height_average_filter_1:
   \   00000080   ........           DC32        ??bmp_h_window
    445          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine23:
   \   00000000   F0BC               POP         {R4-R7}
   \   00000002   04BC               POP         {R2}
   \   00000004   1047               BX          R2                 ;; return
   \   00000006   C046               NOP         
   \                     ??Subroutine23_0:
   \   00000008   ........           DC32        ??bmp_h_window_1
    446          

   \                                 In segment CODE, align 4, keep-with-next
    447          double height_average_filter_for_scp1000(double temp2)//ฦ๘ันผฦธ฿ถศฦฝพ๙ึตยหฒจ
    448          {
   \                     ??height_average_filter_for_scp1000:
   \   00000000   F3B5               PUSH        {R0,R1,R4-R7,LR}
   \   00000002   82B0               SUB         SP,#+8
    449              static double bmp_h_window[15];
    450              double bmp_sum_h = 0;
   \   00000004   0022               MOV         R2,#+0
   \   00000006   0023               MOV         R3,#+0
    451              static int bmp_length = 1;
    452              double bmp_height_filter;
    453              for(char i=1; i<15; i++) //for sum_e and e_window
   \   00000008   0124               MOV         R4,#+1
   \   0000000A   ....               LDR         R6,??Subroutine23_0  ;; ??bmp_h_window_1
    454              {
    455              	bmp_sum_h += bmp_h_window[i];
   \                     ??height_average_filter_for_scp1000_1:
   \   0000000C   E500               LSL         R5,R4,#+3
   \   0000000E   6F46               MOV         R7,SP
   \   00000010   7019               ADD         R0,R6,R5
   \   00000012   03C8               LDMIA       R0!,{R0,R1}
   \   00000014   03C7               STMIA       R7!,{R0,R1}
   \   00000016   6846               MOV         R0,SP
   \   00000018   03C8               LDMIA       R0!,{R0,R1}
   \   0000001A   ........           _BLF        __dAdd,??__dAdd??rT
   \   0000001E   021C               MOV         R2,R0
   \   00000020   0B1C               MOV         R3,R1
    456                  bmp_h_window[i-1] = bmp_h_window[i];
   \   00000022   301C               MOV         R0,R6
   \   00000024   0838               SUB         R0,#+8
   \   00000026   4519               ADD         R5,R0,R5
   \   00000028   6846               MOV         R0,SP
   \   0000002A   03C8               LDMIA       R0!,{R0,R1}
   \   0000002C   03C5               STMIA       R5!,{R0,R1}
    457              }
   \   0000002E   641C               ADD         R4,R4,#+1
   \   00000030   2006               LSL         R0,R4,#+24
   \   00000032   000E               LSR         R0,R0,#+24
   \   00000034   0F28               CMP         R0,#+15
   \   00000036   E9D3               BCC         ??height_average_filter_for_scp1000_1
    458          	 //   e_window[8-1]=e_speed;sum_e += e_speed;
    459                 bmp_h_window[15-1]=temp2;
   \   00000038   7036               ADD         R6,#+112
   \   0000003A   351C               MOV         R5,R6
   \   0000003C   02A8               ADD         R0,SP,#+8
   \   0000003E   03C8               LDMIA       R0!,{R0,R1}
   \   00000040   03C5               STMIA       R5!,{R0,R1}
   \   00000042   083D               SUB         R5,#+8
    460                 bmp_sum_h += temp2;
    461                 bmp_height_filter = bmp_sum_h/bmp_length;
   \   00000044   AC68               LDR         R4,[R5, #+8]
   \   00000046   6E46               MOV         R6,SP
   \   00000048   40B4               PUSH        {R6}
   \   0000004A   03A8               ADD         R0,SP,#+12
   \   0000004C   03C8               LDMIA       R0!,{R0,R1}
   \   0000004E   ........           _BLF        __dAdd,??__dAdd??rT
   \   00000052   061C               MOV         R6,R0
   \   00000054   0F1C               MOV         R7,R1
   \   00000056   201C               MOV         R0,R4
   \   00000058   ........           _BLF        __longToDouble,??__longToDouble??rT
   \   0000005C   021C               MOV         R2,R0
   \   0000005E   0B1C               MOV         R3,R1
   \   00000060   301C               MOV         R0,R6
   \   00000062   391C               MOV         R1,R7
   \   00000064   ........           _BLF        __dDiv,??__dDiv??rT
   \   00000068   40BC               POP         {R6}
   \   0000006A   03C6               STMIA       R6!,{R0,R1}
    462                 
    463                if(bmp_length >= 15)//for length ,max = N
   \   0000006C   0F2C               CMP         R4,#+15
   \   0000006E   01DB               BLT         ??height_average_filter_for_scp1000_2
    464                   bmp_length = 15;
   \   00000070   0F24               MOV         R4,#+15
   \   00000072   00E0               B           ??height_average_filter_for_scp1000_3
    465                else bmp_length++;
   \                     ??height_average_filter_for_scp1000_2:
   \   00000074   641C               ADD         R4,R4,#+1
   \                     ??height_average_filter_for_scp1000_3:
   \   00000076   AC60               STR         R4,[R5, #+8]
    466                
    467               return bmp_height_filter;
   \   00000078   6846               MOV         R0,SP
   \   0000007A   03C8               LDMIA       R0!,{R0,R1}
   \   0000007C   04B0               ADD         SP,#+16
   \   0000007E   C046               NOP         
   \   00000080                      REQUIRE ?Subroutine23
   \   00000080                      ;; // Fall through to label ?Subroutine23
    468          }
    469          
    470          /** read out up for pressure conversion
    471            depending on the oversampling ratio setting up can be 16 to 19 bit
    472             \return up parameter that represents the uncompensated pressure value
    473          */
    474          
    475          //unsigned long bmp085_read_up ()

   \                                 In segment CODE, align 4, keep-with-next
    476          unsigned long bmp085_get_up ()
    477          {
   \                     ??bmp085_get_up:
   \   00000000   71B5               PUSH        {R0,R4-R6,LR}
    478            unsigned char data[3];    
    479            unsigned char ctrl_reg_data;
    480            int comres=0;
    481           
    482            ctrl_reg_data = BMP085_P_MEASURE + (p_bmp085->oversampling_setting << 6);
   \   00000002   ....               LDR         R4,??DataTable36   ;; bmp_update_flag
   \   00000004   606B               LDR         R0,[R4, #+52]
   \   00000006   6946               MOV         R1,SP
   \   00000008   2422               MOV         R2,#+36
   \   0000000A   825E               LDRSH       R2,[R0, R2]
   \   0000000C   9201               LSL         R2,R2,#+6
   \   0000000E   3432               ADD         R2,#+52
   \   00000010   0A70               STRB        R2,[R1, #+0]
    483            comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, BMP085_CTRL_MEAS_REG, &ctrl_reg_data, 1);
   \   00000012   ....               LDR         R5,??DataTable28   ;; 0xfffb8000
   \   00000014   ....               LDR         R6,??DataTable23   ;; 0x770100
   \   00000016   0121               MOV         R1,#+1
   \   00000018   02B4               PUSH        {R1}
   \   0000001A   01A9               ADD         R1,SP,#+4
   \   0000001C   02B4               PUSH        {R1}
   \   0000001E   F423               MOV         R3,#+244
   \   00000020   321C               MOV         R2,R6
   \   00000022   291C               MOV         R1,R5
   \   00000024   ........           BL          ??BMP085_BUS_WRITE_FUNC
    484            
    485           
    486            p_bmp085->AT91F_WaitMiliSecond ( 2 + (3 << (p_bmp085->oversampling_setting) ) );
   \   00000028   606B               LDR         R0,[R4, #+52]
   \   0000002A   0321               MOV         R1,#+3
   \   0000002C   2422               MOV         R2,#+36
   \   0000002E   825E               LDRSH       R2,[R0, R2]
   \   00000030   9140               LSL         R1,R2
   \   00000032   891C               ADD         R1,R1,#+2
   \   00000034   ........           BL          ??AT91F_WaitMiliSecond
    487            
    488            comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_ADC_OUT_MSB_REG, data, 3);
   \   00000038   0320               MOV         R0,#+3
   \   0000003A   01B4               PUSH        {R0}
   \   0000003C   03A8               ADD         R0,SP,#+12
   \   0000003E   401C               ADD         R0,R0,#+1
   \   00000040   01B4               PUSH        {R0}
   \   00000042   F623               MOV         R3,#+246
   \   00000044   321C               MOV         R2,R6
   \   00000046   291C               MOV         R1,R5
   \   00000048   606B               LDR         R0,[R4, #+52]
   \   0000004A   ........           BL          ??BMP085_BUS_READ_FUNC
    489            up = (((unsigned long) data[0] << 16) | ((unsigned long) data[1] << 8) | (unsigned long) data[2]) >> (8-p_bmp085->oversampling_setting);
   \   0000004E   616B               LDR         R1,[R4, #+52]
   \   00000050   04A8               ADD         R0,SP,#+16
   \   00000052   4078               LDRB        R0,[R0, #+1]
   \   00000054   0004               LSL         R0,R0,#+16
   \   00000056   04AA               ADD         R2,SP,#+16
   \   00000058   521C               ADD         R2,R2,#+1
   \   0000005A   5278               LDRB        R2,[R2, #+1]
   \   0000005C   1202               LSL         R2,R2,#+8
   \   0000005E   0243               ORR         R2,R0
   \   00000060   04A8               ADD         R0,SP,#+16
   \   00000062   401C               ADD         R0,R0,#+1
   \   00000064   8078               LDRB        R0,[R0, #+2]
   \   00000066   1043               ORR         R0,R2
   \   00000068   0822               MOV         R2,#+8
   \   0000006A   2423               MOV         R3,#+36
   \   0000006C   CB5E               LDRSH       R3,[R1, R3]
   \   0000006E   D21A               SUB         R2,R2,R3
   \   00000070   D040               LSR         R0,R2
   \   00000072   2064               STR         R0,[R4, #+64]
    490            p_bmp085->number_of_samples = 1;
   \   00000074   0122               MOV         R2,#+1
   \   00000076   0A62               STR         R2,[R1, #+32]
    491             
    492            return (up);
   \   00000078   05B0               ADD         SP,#+20
   \   0000007A   C046               NOP         
   \   0000007C                      REQUIRE ?Subroutine22
   \   0000007C                      ;; // Fall through to label ?Subroutine22
    493            
    494          }
    495          
    496          //----------------------------------------------------------------
    497          /** initialize HMC5843
    498          
    499          */
    500          

   \                                 In segment CODE, align 4, keep-with-next
    501          int hmc_init() 
    502          {
   \                     ??hmc_init:
   \   00000000   71B5               PUSH        {R0,R4-R6,LR}
    503            char comres=0;
    504            unsigned char cle_reg_data = 0x00;
   \   00000002   6846               MOV         R0,SP
   \   00000004   0021               MOV         R1,#+0
   \   00000006   0170               STRB        R1,[R0, #+0]
    505            unsigned char cle_reg_data1 = 0x14;
   \   00000008   1421               MOV         R1,#+20
   \   0000000A   4170               STRB        R1,[R0, #+1]
    506            comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,HMC5843_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, HMC5843_MODE_ADDR, &cle_reg_data, 1);
   \   0000000C   ....               LDR         R4,??DataTable36   ;; bmp_update_flag
   \   0000000E   ....               LDR         R5,??DataTable28   ;; 0xfffb8000
   \   00000010   ....               LDR         R6,??DataTable27   ;; 0x1e0100
   \   00000012   0120               MOV         R0,#+1
   \   00000014   01B4               PUSH        {R0}
   \   00000016   01A8               ADD         R0,SP,#+4
   \   00000018   01B4               PUSH        {R0}
   \   0000001A   0223               MOV         R3,#+2
   \   0000001C   321C               MOV         R2,R6
   \   0000001E   291C               MOV         R1,R5
   \   00000020   606B               LDR         R0,[R4, #+52]
   \   00000022   ........           BL          ??BMP085_BUS_WRITE_FUNC
    507            comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,HMC5843_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, HMC5843_CONFIGUREA_ADDR, &cle_reg_data1, 1);
   \   00000026   0120               MOV         R0,#+1
   \   00000028   01B4               PUSH        {R0}
   \   0000002A   03A8               ADD         R0,SP,#+12
   \   0000002C   401C               ADD         R0,R0,#+1
   \   0000002E   01B4               PUSH        {R0}
   \   00000030   0023               MOV         R3,#+0
   \   00000032   321C               MOV         R2,R6
   \   00000034   291C               MOV         R1,R5
   \   00000036   606B               LDR         R0,[R4, #+52]
   \   00000038   ........           BL          ??BMP085_BUS_WRITE_FUNC
    508            //comres += p_bmp085->BMP085_BUS_WRITE_FUNC(HMC5843_I2C_ADDR_write, HMC5843_MODE_ADDR,AT91C_TWI_IADRSZ_1_BYTE,&cle_reg_data);
    509          
    510            return comres;
   \   0000003C   0006               LSL         R0,R0,#+24
   \   0000003E   000E               LSR         R0,R0,#+24
   \   00000040   05B0               ADD         SP,#+20
   \   00000042   ....               B           ?Subroutine22
    511          
    512          }
    513          
    514          /** read out parameters cal_param from HMC5843 memory
    515             \return result of communication routines
    516          */
    517          

   \                                 In segment CODE, align 4, keep-with-next
    518          long hmc_get_data(char reg_adrr)
    519          {
   \                     ??hmc_get_data:
   \   00000000   01B5               PUSH        {R0,LR}
    520            int comres = 0;
    521            unsigned char data[2];
    522            long value;
    523            comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,HMC5843_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, reg_adrr, data, 2);
   \   00000002   0221               MOV         R1,#+2
   \   00000004   02B4               PUSH        {R1}
   \   00000006   01A9               ADD         R1,SP,#+4
   \   00000008   02B4               PUSH        {R1}
   \   0000000A   031C               MOV         R3,R0
   \   0000000C   ....               LDR         R2,??DataTable27   ;; 0x1e0100
   \   0000000E   ....               LDR         R1,??DataTable28   ;; 0xfffb8000
   \   00000010   ....               LDR         R0,??DataTable29   ;; bmp_update_flag + 52
   \   00000012   0068               LDR         R0,[R0, #+0]
   \   00000014   ........           BL          ??BMP085_BUS_READ_FUNC
    524            //comres += p_bmp085->BMP085_BUS_READ_FUNC(HMC5843_I2C_ADDR_read,reg_adrr,AT91C_TWI_IADRSZ_1_BYTE,data,2);
    525            //comres = p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_PROM_START__ADDR, data, BMP085_PROM_DATA__LEN);
    526            
    527            /*parameters*/
    528            value =  (data[0] <<8) | data[1];
    529            return value;   
   \   00000018   02A8               ADD         R0,SP,#+8
   \   0000001A   0078               LDRB        R0,[R0, #+0]
   \   0000001C   0102               LSL         R1,R0,#+8
   \   0000001E   02A8               ADD         R0,SP,#+8
   \   00000020   4078               LDRB        R0,[R0, #+1]
   \   00000022   0843               ORR         R0,R1
   \   00000024   0EBC               POP         {R1-R3}
   \   00000026   02BC               POP         {R1}
   \   00000028   0847               BX          R1                 ;; return
    530          }
    531          //------------------------------------------syc

   \                                 In segment CODE, align 4, keep-with-next
    532          void bmp085_update(void)
    533          { 
   \                     ??bmp085_update:
   \   00000000   F0B5               PUSH        {R4-R7,LR}
    534            //double limit=0;
    535            static unsigned int zero_count = 1 ;
    536            //static double last_bmp_height=0;
    537            
    538            bmp085_get_temperature(ut);
   \   00000002   ....               LDR         R4,??DataTable36   ;; bmp_update_flag
   \   00000004   606C               LDR         R0,[R4, #+68]
   \   00000006   ........           BL          ??bmp085_get_temperature
    539            bmp085_get_pressure(up);
   \   0000000A   206C               LDR         R0,[R4, #+64]
   \   0000000C   ........           BL          ??bmp085_get_pressure
    540            bmp_height = 44330*(1-pow((pressure/101325.0),0.190294957));
   \   00000010   ....               LDR         R2,??DataTable37   ;; 0xcc745124
   \   00000012   ....               LDR         R3,??DataTable38   ;; 0x3fc85b95
   \   00000014   161C               MOV         R6,R2
   \   00000016   1F1C               MOV         R7,R3
   \   00000018   A06C               LDR         R0,[R4, #+72]
   \   0000001A   ........           _BLF        __longToDouble,??__longToDouble??rT
   \   0000001E   0022               MOV         R2,#+0
   \   00000020   ....               LDR         R3,??DataTable39   ;; 0x40f8bcd0
   \   00000022   ........           _BLF        __dDiv,??__dDiv??rT
   \   00000026   321C               MOV         R2,R6
   \   00000028   3B1C               MOV         R3,R7
   \   0000002A   ........           _BLF        pow,??pow??rT
   \   0000002E   021C               MOV         R2,R0
   \   00000030   0B1C               MOV         R3,R1
   \   00000032   0020               MOV         R0,#+0
   \   00000034   ....               LDR         R1,??DataTable40   ;; 0x3ff00000
   \   00000036   ........           _BLF        __dSub,??__dSub??rT
   \   0000003A   0022               MOV         R2,#+0
   \   0000003C   ....               LDR         R3,??DataTable41   ;; 0x40e5a540
   \   0000003E   ........           _BLF        __dMul,??__dMul??rT
   \   00000042   221C               MOV         R2,R4
   \   00000044   0C32               ADD         R2,#+12
   \   00000046   03C2               STMIA       R2!,{R0,R1}
    541            bmp_height=height_average_filter(bmp_height);
   \   00000048   201C               MOV         R0,R4
   \   0000004A   0C30               ADD         R0,#+12
   \   0000004C   03C8               LDMIA       R0!,{R0,R1}
   \   0000004E   ........           BL          ??height_average_filter
   \   00000052   221C               MOV         R2,R4
   \   00000054   0C32               ADD         R2,#+12
   \   00000056   03C2               STMIA       R2!,{R0,R1}
    542            
    543             if(zero_count==300)
   \   00000058   E26C               LDR         R2,[R4, #+76]
   \   0000005A   9620               MOV         R0,#+150
   \   0000005C   4000               LSL         R0,R0,#+1          ;; #+300
   \   0000005E   8242               CMP         R2,R0
   \   00000060   05D1               BNE         ??bmp085_update_1
    544                 zero_bmp_height=bmp_height;//ศกธ฿ถศฯ๎มใตใ
   \   00000062   231C               MOV         R3,R4
   \   00000064   2433               ADD         R3,#+36
   \   00000066   201C               MOV         R0,R4
   \   00000068   0C30               ADD         R0,#+12
   \   0000006A   03C8               LDMIA       R0!,{R0,R1}
   \   0000006C   03C3               STMIA       R3!,{R0,R1}
    545             zero_count ++ ;
   \                     ??bmp085_update_1:
   \   0000006E   521C               ADD         R2,R2,#+1
    546             if(zero_count >=400)
   \   00000070   C820               MOV         R0,#+200
   \   00000072   4000               LSL         R0,R0,#+1          ;; #+400
   \   00000074   8242               CMP         R2,R0
   \   00000076   01D3               BCC         ??bmp085_update_2
    547                zero_count = 350;
   \   00000078   AF22               MOV         R2,#+175
   \   0000007A   5200               LSL         R2,R2,#+1          ;; #+350
   \                     ??bmp085_update_2:
   \   0000007C   E264               STR         R2,[R4, #+76]
    548             
    549             bmp_height=zero_bmp_height-bmp_height;
   \   0000007E   251C               MOV         R5,R4
   \   00000080   0C35               ADD         R5,#+12
   \   00000082   201C               MOV         R0,R4
   \   00000084   2430               ADD         R0,#+36
   \   00000086   03C8               LDMIA       R0!,{R0,R1}
   \   00000088   0C34               ADD         R4,#+12
   \   0000008A   0CCC               LDMIA       R4!,{R2,R3}
   \   0000008C   ........           _BLF        __dSub,??__dSub??rT
   \   00000090   03C5               STMIA       R5!,{R0,R1}
    550          }
   \   00000092   ....               B           ?Subroutine24

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine24:
   \   00000000   F0BC               POP         {R4-R7}
   \   00000002   01BC               POP         {R0}
   \   00000004   0047               BX          R0                 ;; return
   \   00000006   C046               NOP         
   \                     ??Subroutine24_0:
   \   00000008   2000FAFF           DC32        0xfffa0020
   \   0000000C   ........           DC32        bmp_update_flag
   \   00000010   1400FAFF           DC32        0xfffa0014
   \   00000014   FFFF0000           DC32        0xffff
   \   00000018   0C00FEFF           DC32        0xfffe000c
   \   0000001C   ........           DC32        imuaddress
   \   00000020   1000FEFF           DC32        0xfffe0010
   \   00000024   ........           DC32        imuframe
   \   00000028   0800FEFF           DC32        0xfffe0008
   \   0000002C   1000FAFF           DC32        0xfffa0010
   \   00000030   2800FAFF           DC32        0xfffa0028
   \   00000034   ........           DC32        hmc_update_flag
   \   00000038   1000FAFF           DC32        0xfffa0010
    551          

   \                                 In segment CODE, align 4, keep-with-next
    552          void scp1000_update(void)
    553          { 
   \                     ??scp1000_update:
   \   00000000   D0B5               PUSH        {R4,R6,R7,LR}
    554            static unsigned int zero_count = 1 ;
    555            scp_height = 44330*(1-pow((scp_pressure/101325.0),0.190294957));
   \   00000002   ....               LDR         R4,??DataTable36   ;; bmp_update_flag
   \   00000004   ....               LDR         R2,??DataTable37   ;; 0xcc745124
   \   00000006   ....               LDR         R3,??DataTable38   ;; 0x3fc85b95
   \   00000008   161C               MOV         R6,R2
   \   0000000A   1F1C               MOV         R7,R3
   \   0000000C   201C               MOV         R0,R4
   \   0000000E   2C30               ADD         R0,#+44
   \   00000010   03C8               LDMIA       R0!,{R0,R1}
   \   00000012   0022               MOV         R2,#+0
   \   00000014   ....               LDR         R3,??DataTable39   ;; 0x40f8bcd0
   \   00000016   ........           _BLF        __dDiv,??__dDiv??rT
   \   0000001A   321C               MOV         R2,R6
   \   0000001C   3B1C               MOV         R3,R7
   \   0000001E   ........           _BLF        pow,??pow??rT
   \   00000022   021C               MOV         R2,R0
   \   00000024   0B1C               MOV         R3,R1
   \   00000026   0020               MOV         R0,#+0
   \   00000028   ....               LDR         R1,??DataTable40   ;; 0x3ff00000
   \   0000002A   ........           _BLF        __dSub,??__dSub??rT
   \   0000002E   0022               MOV         R2,#+0
   \   00000030   ....               LDR         R3,??DataTable41   ;; 0x40e5a540
   \   00000032   ........           _BLF        __dMul,??__dMul??rT
   \   00000036   221C               MOV         R2,R4
   \   00000038   1432               ADD         R2,#+20
   \   0000003A   03C2               STMIA       R2!,{R0,R1}
    556            if(zero_count==1) zero_scp_height=scp_height;     
   \   0000003C   206D               LDR         R0,[R4, #+80]
   \   0000003E   0128               CMP         R0,#+1
   \   00000040   05D1               BNE         ??scp1000_update_1
   \   00000042   221C               MOV         R2,R4
   \   00000044   1C32               ADD         R2,#+28
   \   00000046   201C               MOV         R0,R4
   \   00000048   1430               ADD         R0,#+20
   \   0000004A   03C8               LDMIA       R0!,{R0,R1}
   \   0000004C   03C2               STMIA       R2!,{R0,R1}
    557              zero_count = 2 ;
   \                     ??scp1000_update_1:
   \   0000004E   0220               MOV         R0,#+2
   \   00000050   2065               STR         R0,[R4, #+80]
   \   00000052   201C               MOV         R0,R4
   \   00000054   1C30               ADD         R0,#+28
   \   00000056   03C8               LDMIA       R0!,{R0,R1}
   \   00000058   221C               MOV         R2,R4
   \   0000005A   1432               ADD         R2,#+20
   \   0000005C   0CCA               LDMIA       R2!,{R2,R3}
   \   0000005E   ........           _BLF        __dSub,??__dSub??rT
   \   00000062   221C               MOV         R2,R4
   \   00000064   1432               ADD         R2,#+20
   \   00000066   03C2               STMIA       R2!,{R0,R1}
    558            scp_height = zero_scp_height - scp_height;
    559            bmp_height = scp_height;
   \   00000068   0C34               ADD         R4,#+12
   \   0000006A   03C4               STMIA       R4!,{R0,R1}
    560          }
   \   0000006C   D0BC               POP         {R4,R6,R7}
   \   0000006E   01BC               POP         {R0}
   \   00000070   0047               BX          R0                 ;; return

   \                                 In segment DATA_I, align 4, align-sorted
   \                     bmp_update_flag:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for bmp_update_flag>`
   \                     imu_num:
   \   00000001                      DS8 1
   \   00000002                      REQUIRE `?<Initializer for imu_num>`
   \                     scp_num:
   \   00000002                      DS8 1
   \   00000003                      REQUIRE `?<Initializer for scp_num>`
   \                     HDG:
   \   00000003                      DS8 1
   \   00000004                      REQUIRE `?<Initializer for HDG>`
   \                     imu_update_flag:
   \   00000004                      DS8 1
   \   00000005                      REQUIRE `?<Initializer for imu_update_flag>`
   \                     raw_imu_update:
   \   00000005                      DS8 1
   \   00000006                      REQUIRE `?<Initializer for raw_imu_update>`
   \                     scp_status:
   \   00000006                      DS8 1
   \   00000007                      REQUIRE `?<Initializer for scp_status>`
   \   00000007                      DS8 1
   \                     temperature:
   \   00000008                      DS8 2
   \   0000000A                      REQUIRE `?<Initializer for temperature>`
   \   0000000A                      DS8 2
   \                     bmp_height:
   \   0000000C                      DS8 8
   \   00000014                      REQUIRE `?<Initializer for bmp_height>`
   \                     scp_height:
   \   00000014                      DS8 8
   \   0000001C                      REQUIRE `?<Initializer for scp_height>`
   \                     zero_scp_height:
   \   0000001C                      DS8 8
   \   00000024                      REQUIRE `?<Initializer for zero_scp_height>`
   \                     zero_bmp_height:
   \   00000024                      DS8 8
   \   0000002C                      REQUIRE `?<Initializer for zero_bmp_height>`
   \                     scp_pressure:
   \   0000002C                      DS8 8
   \   00000034                      REQUIRE `?<Initializer for scp_pressure>`
   \                     p_bmp085:
   \   00000034                      DS8 4
   \   00000038                      REQUIRE `?<Initializer for p_bmp085>`
   \                     imu_count:
   \   00000038                      DS8 4
   \   0000003C                      REQUIRE `?<Initializer for imu_count>`
   \                     timer0_num:
   \   0000003C                      DS8 4
   \   00000040                      REQUIRE `?<Initializer for timer0_num>`
   \                     up:
   \   00000040                      DS8 4
   \   00000044                      REQUIRE `?<Initializer for up>`
   \                     ut:
   \   00000044                      DS8 4
   \   00000048                      REQUIRE `?<Initializer for ut>`
   \                     pressure:
   \   00000048                      DS8 4
   \   0000004C                      REQUIRE `?<Initializer for pressure>`
   \   0000004C                      DS8 4
   \   00000050                      REQUIRE `?<Initializer for zero_count>`
   \   00000050                      DS8 4
   \   00000054                      REQUIRE `?<Initializer for zero_count>_1`
   \                     lidar_lite_distance:
   \   00000054                      DS8 8
   \   0000005C                      REQUIRE `?<Initializer for lidar_lite_distance>`

   \                                 In segment DATA_I, align 4, align-sorted
   \                     ??bmp_h_window:
   \   00000000                      DS8 56
   \   00000038                      REQUIRE `?<Initializer for bmp_h_window>`
   \   00000038                      DS8 4
   \   0000003C                      REQUIRE `?<Initializer for bmp_length>`

   \                                 In segment DATA_I, align 4, align-sorted
   \                     ??bmp_h_window_1:
   \   00000000                      DS8 120
   \   00000078                      REQUIRE `?<Initializer for bmp_h_window>_1`
   \   00000078                      DS8 4
   \   0000007C                      REQUIRE `?<Initializer for bmp_length>_1`
    561          

   \                                 In segment CODE, align 4, keep-with-next
    562          void hmc_update(void)
    563          {
   \                     ??hmc_update:
   \   00000000   11B5               PUSH        {R0,R4,LR}
    564            char * line=NULL ; 
   \   00000002   0020               MOV         R0,#+0
   \   00000004   0090               STR         R0,[SP, #+0]
    565            line = index(hmc_save_line,',');
   \   00000006   1748               LDR         R0,??hmc_update_1  ;; hmc_save_line
   \   00000008   04E0               B           ??hmc_update_2
   \                     ??hmc_update_3:
   \   0000000A   011C               MOV         R1,R0
   \   0000000C   401C               ADD         R0,R0,#+1
   \   0000000E   0978               LDRB        R1,[R1, #+0]
   \   00000010   0029               CMP         R1,#+0
   \   00000012   23D0               BEQ         ??hmc_update_4
   \                     ??hmc_update_2:
   \   00000014   0178               LDRB        R1,[R0, #+0]
   \   00000016   2C29               CMP         R1,#+44
   \   00000018   F7D1               BNE         ??hmc_update_3
   \   0000001A   0090               STR         R0,[SP, #+0]
    566            if(!line)
   \   0000001C   0028               CMP         R0,#+0
   \   0000001E   1DD0               BEQ         ??hmc_update_4
    567                return ;
    568            line++;//skip ,
   \   00000020   401C               ADD         R0,R0,#+1
   \   00000022   0090               STR         R0,[SP, #+0]
    569            pni_value[ INDEX_CX ]  = strtod( line, &line );
   \   00000024   104C               LDR         R4,??hmc_update_1+0x4  ;; pni_value
   \   00000026   0022               MOV         R2,#+0
   \   00000028   6946               MOV         R1,SP
   \   0000002A   ........           _BLF        _Stod,??_Stod??rT
   \   0000002E   ........           _BLF        __doubleToLong,??__doubleToLong??rT
   \   00000032   2060               STR         R0,[R4, #+0]
    570            
    571              line++;//skip ,
   \   00000034   0098               LDR         R0,[SP, #+0]
   \   00000036   401C               ADD         R0,R0,#+1
   \   00000038   0090               STR         R0,[SP, #+0]
    572            pni_value[ INDEX_CY ]  = strtod( line, &line );
   \   0000003A   0022               MOV         R2,#+0
   \   0000003C   6946               MOV         R1,SP
   \   0000003E   ........           _BLF        _Stod,??_Stod??rT
   \   00000042   ........           _BLF        __doubleToLong,??__doubleToLong??rT
   \   00000046   6060               STR         R0,[R4, #+4]
    573            
    574              line++;//skip ,
   \   00000048   0098               LDR         R0,[SP, #+0]
   \   0000004A   401C               ADD         R0,R0,#+1
   \   0000004C   0090               STR         R0,[SP, #+0]
    575            pni_value[ INDEX_CZ ]  = strtod( line, &line );
   \   0000004E   0022               MOV         R2,#+0
   \   00000050   6946               MOV         R1,SP
   \   00000052   ........           _BLF        _Stod,??_Stod??rT
   \   00000056   ........           _BLF        __doubleToLong,??__doubleToLong??rT
   \   0000005A   A060               STR         R0,[R4, #+8]
    576           
    577            return;
   \                     ??hmc_update_4:
   \   0000005C   18BC               POP         {R3,R4}
   \   0000005E   01BC               POP         {R0}
   \   00000060   0047               BX          R0                 ;; return
   \   00000062   C046               NOP         
   \                     ??hmc_update_1:
   \   00000064   ........           DC32        hmc_save_line
   \   00000068   ........           DC32        pni_value
    578          }
    579          
    580          //----------------------------------------------------------------
    581          /** timer0ึะถฯบฏส
    582          
    583              ธรึะถฯบฏสสว2014ฤ๊พษฐๆทษฟุฐๅตฤึะถฯบฏสฃฌพษฐๆษฯรๆำะbmp085บอhmcดซธะฦ๗ฃฌรปำะscp1000
    584          */
    585          //void timer0_c_irq_handler(void)
    586          //{
    587          //  int dummy;
    588          //  unsigned char data[2];
    589          //  unsigned char data1[3];
    590          //  unsigned char ctrl_reg_data;
    591          //  int comres;
    592          //  dummy =AT91C_BASE_TC0->TC_SR;
    593          //  dummy =dummy;
    594          //  //timer0_num++;
    595          //  if(HDG == 1)
    596          //  {  timer0_num++;
    597          //     AT91F_SPI_PutChar(AT91C_BASE_SPI,imuaddress[imu_num],0);
    598          //     imu_count ++;
    599          //   
    600          //     int temp = 0;
    601          //     while((AT91C_BASE_SPI->SPI_SR & AT91C_SPI_TXEMPTY)==0)
    602          //     {
    603          //        temp ++;
    604          //        if (temp >200)
    605          //         break;
    606          //      }
    607          //       if(imu_num!=0)
    608          //              imuframe[imu_num-1]=AT91F_SPI_GetChar(AT91C_BASE_SPI);
    609          //          else 
    610          //             imuframe[7]=AT91F_SPI_GetChar(AT91C_BASE_SPI);    
    611          //   
    612          //        imu_num ++;
    613          //        imu_num=imu_num%8;
    614          //       if(imu_num==0) 
    615          //        {
    616          //          raw_imu_update = true ;
    617          //          imu_update_flag = 1;
    618          //          HDG=0; 
    619          //        }
    620          //       AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+250;
    621          //  }
    622          //  else
    623          //  {
    624          //    if(HDG==0)
    625          //    {  timer0_num++;
    626          //       if(bmphmc_num == 6)
    627          //       {
    628          //         bmphmc_num = 0;         
    629          //         HDG=2;
    630          //         bmp_update_flag=2;
    631          //         AT91F_TC_InterruptDisable(AT91C_BASE_TC0,AT91C_TC_CPAS);
    632          //         timer0_num=0;
    633          //       }
    634          //        else
    635          //        {
    636          ////		  hmc_init();
    637          //          switch(bmphmc_num)
    638          //            {
    639          //               
    640          //               case 0 :  ctrl_reg_data = BMP085_T_MEASURE;
    641          //                         comres = p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, BMP085_CTRL_MEAS_REG, &ctrl_reg_data, 1);
    642          //                         bmphmc_num++;
    643          //                         AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+37500;
    644          //                         break;
    645          //               case 1 :  comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_ADC_OUT_MSB_REG, data, 2);
    646          //                         ut = ((unsigned long)data[0] <<8) | (unsigned long)data[1];
    647          //                        // bmp085_get_temperature(ut);
    648          //                         bmphmc_num++;
    649          //                         AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+200;
    650          //                         break;
    651          //               case 2 :  ctrl_reg_data = BMP085_P_MEASURE + (p_bmp085->oversampling_setting << 6);
    652          //                         comres += p_bmp085->BMP085_BUS_WRITE_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_write | AT91C_TWI_IADRSZ_1_BYTE, BMP085_CTRL_MEAS_REG, &ctrl_reg_data, 1);
    653          //                         bmphmc_num++;
    654          //                         AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+52500;
    655          //                         break;
    656          //               case 3:   bmphmc_num++;
    657          //                         AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+52500;
    658          //                         break;   
    659          //               case 4 :  comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,BMP085_I2C_ADDR_read | AT91C_TWI_IADRSZ_1_BYTE, BMP085_ADC_OUT_MSB_REG, data1, 3);
    660          //                         up = (((unsigned long) data1[0] << 16) | ((unsigned long) data1[1] << 8) | (unsigned long) data1[2]) >> (8-p_bmp085->oversampling_setting);
    661          //                         p_bmp085->number_of_samples = 1;
    662          //                         //bmp085_get_pressure(up);
    663          //                         //bmp_height = 44330*(1-pow((pressure/101325.0),0.190294957));
    664          //                         //bmp_height=height_average_filter(bmp_height);
    665          //                         bmphmc_num++;
    666          //                         AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+3500;
    667          //                         break;
    668          //              case 5:   if(hmc_update_flag==true)
    669          //                        {
    670          //                            hmc_update();
    671          //                            hmc_update_flag = false;
    672          //                        }
    673          //                        bmphmc_num++;
    674          //                        AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+350;
    675          //                        break; 
    676          //              default : break;
    677          //            }
    678          //        }
    679          //     }//HDG==0
    680          //  }
    681          //}
    682          
    683          
    684          /** timer0ึะถฯบฏส
    685          
    686              ธรึะถฯบฏสสว2015ฤ๊ะยฐๆทษฟุฐๅตฤึะถฯบฏสฃฌธะยimuำ๋scp1000
    687          */

   \                                 In segment CODE, align 4, keep-with-next
    688          void timer0_c_irq_handler(void)
    689          {
   \                     ??timer0_c_irq_handler:
   \   00000000   F0B5               PUSH        {R4-R7,LR}
    690            int dummy;
    691          // unsigned char data[2];
    692          //unsigned char data1[3];
    693          //unsigned char ctrl_reg_data;
    694            int comres = 0;
    695            dummy =AT91C_BASE_TC0->TC_SR;
   \   00000002   ....               LDR         R0,??Subroutine24_0  ;; 0xfffa0020
   \   00000004   0068               LDR         R0,[R0, #+0]
    696            dummy =dummy;
    697            //timer0_num++;
    698            if(HDG == 1)
   \   00000006   ....               LDR         R4,??Subroutine24_0+0x4  ;; bmp_update_flag
   \   00000008   E16B               LDR         R1,[R4, #+60]
   \   0000000A   491C               ADD         R1,R1,#+1
   \   0000000C   E278               LDRB        R2,[R4, #+3]
   \   0000000E   0020               MOV         R0,#+0
   \   00000010   ....               LDR         R5,??Subroutine24_0+0x8  ;; 0xfffa0014
   \   00000012   012A               CMP         R2,#+1
   \   00000014   33D1               BNE         ??timer0_c_irq_handler_1
    699            {  timer0_num++;
   \   00000016   E163               STR         R1,[R4, #+60]
    700               AT91F_SPI_PutChar(AT91C_BASE_SPI,imuaddress[imu_num],0);
   \   00000018   6178               LDRB        R1,[R4, #+1]
   \   0000001A   8A00               LSL         R2,R1,#+2
   \   0000001C   ....               LDR         R3,??Subroutine24_0+0xC  ;; 0xffff
   \   0000001E   ....               LDR         R7,??Subroutine24_0+0x10  ;; 0xfffe000c
   \   00000020   BC46               MOV         R12,R7
   \   00000022   ....               LDR         R6,??Subroutine24_0+0x14  ;; imuaddress
   \   00000024   B758               LDR         R7,[R6, R2]
   \   00000026   1F40               AND         R7,R3
   \   00000028   E026               MOV         R6,#+224
   \   0000002A   3603               LSL         R6,R6,#+12         ;; #+917504
   \   0000002C   3E43               ORR         R6,R7
   \   0000002E   6746               MOV         R7,R12
   \   00000030   3E60               STR         R6,[R7, #+0]
    701               imu_count ++;
   \   00000032   A66B               LDR         R6,[R4, #+56]
   \   00000034   761C               ADD         R6,R6,#+1
   \   00000036   A663               STR         R6,[R4, #+56]
    702             
    703               int temp = 0;
    704               while((AT91C_BASE_SPI->SPI_SR & AT91C_SPI_TXEMPTY)==0)
   \                     ??timer0_c_irq_handler_2:
   \   00000038   ....               LDR         R6,??Subroutine24_0+0x18  ;; 0xfffe0010
   \   0000003A   3668               LDR         R6,[R6, #+0]
   \   0000003C   B605               LSL         R6,R6,#+22
   \   0000003E   02D4               BMI         ??timer0_c_irq_handler_3
    705               {
    706                  temp ++;
   \   00000040   401C               ADD         R0,R0,#+1
    707                  if (temp >200)
   \   00000042   C928               CMP         R0,#+201
   \   00000044   F8DB               BLT         ??timer0_c_irq_handler_2
    708                   break;
    709                }
    710                 if(imu_num!=0)
   \                     ??timer0_c_irq_handler_3:
   \   00000046   ....               LDR         R0,??Subroutine24_0+0x1C  ;; imuframe
   \   00000048   ....               LDR         R6,??Subroutine24_0+0x20  ;; 0xfffe0008
   \   0000004A   0029               CMP         R1,#+0
   \   0000004C   05D0               BEQ         ??timer0_c_irq_handler_4
    711                        imuframe[imu_num-1]=AT91F_SPI_GetChar(AT91C_BASE_SPI);
   \   0000004E   3668               LDR         R6,[R6, #+0]
   \   00000050   8018               ADD         R0,R0,R2
   \   00000052   001F               SUB         R0,R0,#+4
   \   00000054   3340               AND         R3,R6
   \   00000056   0360               STR         R3,[R0, #+0]
   \   00000058   02E0               B           ??timer0_c_irq_handler_5
    712                    else 
    713                       imuframe[7]=AT91F_SPI_GetChar(AT91C_BASE_SPI);    
   \                     ??timer0_c_irq_handler_4:
   \   0000005A   3268               LDR         R2,[R6, #+0]
   \   0000005C   1340               AND         R3,R2
   \   0000005E   C361               STR         R3,[R0, #+28]
    714             
    715                  imu_num ++;
    716                  imu_num=imu_num%8;
   \                     ??timer0_c_irq_handler_5:
   \   00000060   491C               ADD         R1,R1,#+1
   \   00000062   4807               LSL         R0,R1,#+29
   \   00000064   400F               LSR         R0,R0,#+29
   \   00000066   6070               STRB        R0,[R4, #+1]
    717                 if(imu_num==0) 
   \   00000068   04D1               BNE         ??timer0_c_irq_handler_6
    718                  {
    719                    raw_imu_update = true ;
   \   0000006A   0120               MOV         R0,#+1
   \   0000006C   6071               STRB        R0,[R4, #+5]
    720                    imu_update_flag = 1;
   \   0000006E   2071               STRB        R0,[R4, #+4]
    721                    HDG=0; 
   \   00000070   0020               MOV         R0,#+0
   \   00000072   E070               STRB        R0,[R4, #+3]
    722                  }
    723                 AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+250;
   \                     ??timer0_c_irq_handler_6:
   \   00000074   ....               LDR         R0,??Subroutine24_0+0x24  ;; 0xfffa0010
   \   00000076   0068               LDR         R0,[R0, #+0]
   \   00000078   FA30               ADD         R0,#+250
   \   0000007A   2860               STR         R0,[R5, #+0]
   \   0000007C   34E0               B           ??timer0_c_irq_handler_7
    724            }
    725            else
    726            {
    727              if(HDG==0)
   \                     ??timer0_c_irq_handler_1:
   \   0000007E   002A               CMP         R2,#+0
   \   00000080   32D1               BNE         ??timer0_c_irq_handler_7
    728              {  timer0_num++;
   \   00000082   E163               STR         R1,[R4, #+60]
    729                 if(scp_num == 1)
   \   00000084   A178               LDRB        R1,[R4, #+2]
   \   00000086   0129               CMP         R1,#+1
   \   00000088   08D1               BNE         ??timer0_c_irq_handler_8
    730                 {
    731                   scp_num = 0;         
   \   0000008A   A070               STRB        R0,[R4, #+2]
    732                   HDG=2;
   \   0000008C   0221               MOV         R1,#+2
   \   0000008E   E170               STRB        R1,[R4, #+3]
    733                   bmp_update_flag=2;
   \   00000090   2170               STRB        R1,[R4, #+0]
    734                   AT91F_TC_InterruptDisable(AT91C_BASE_TC0,AT91C_TC_CPAS);
   \   00000092   ....               LDR         R1,??Subroutine24_0+0x28  ;; 0xfffa0028
   \   00000094   0422               MOV         R2,#+4
   \   00000096   0A60               STR         R2,[R1, #+0]
    735                   timer0_num=0;
   \   00000098   E063               STR         R0,[R4, #+60]
   \   0000009A   25E0               B           ??timer0_c_irq_handler_7
    736                 }
    737                  else
    738                  {
    739                    switch(scp_num)
   \                     ??timer0_c_irq_handler_8:
   \   0000009C   0029               CMP         R1,#+0
   \   0000009E   23D1               BNE         ??timer0_c_irq_handler_7
    740                      {
    741                         
    742                         case 0 : 
    743                                  if(hmc_update_flag==true)
   \   000000A0   ....               LDR         R6,??Subroutine24_0+0x2C  ;; hmc_update_flag
   \   000000A2   3078               LDRB        R0,[R6, #+0]
   \   000000A4   0028               CMP         R0,#+0
   \   000000A6   03D0               BEQ         ??timer0_c_irq_handler_9
    744                                  {
    745                                      hmc_update();
   \   000000A8   ........           BL          ??hmc_update
    746                                      hmc_update_flag = false;
   \   000000AC   0020               MOV         R0,#+0
   \   000000AE   3070               STRB        R0,[R6, #+0]
    747                                  };
    748                                  comres += p_bmp085->BMP085_BUS_READ_FUNC(AT91C_BASE_TWI,SPC1000AddrR | AT91C_TWI_IADRSZ_1_BYTE, STATUS,&scp_status, 1);
   \                     ??timer0_c_irq_handler_9:
   \   000000B0   0120               MOV         R0,#+1
   \   000000B2   01B4               PUSH        {R0}
   \   000000B4   A01D               ADD         R0,R4,#+6
   \   000000B6   01B4               PUSH        {R0}
   \   000000B8   0723               MOV         R3,#+7
   \   000000BA   ....               LDR         R2,??DataTable42   ;; 0x110100
   \   000000BC   ....               LDR         R1,??DataTable43   ;; 0xfffb8000
   \   000000BE   606B               LDR         R0,[R4, #+52]
   \   000000C0   ........           BL          ??BMP085_BUS_READ_FUNC
    749                                  scp1000_pressure(&scp_pressure);
   \   000000C4   201C               MOV         R0,R4
   \   000000C6   2C30               ADD         R0,#+44
   \   000000C8   ........           BL          ??scp1000_pressure
    750                                  lidar_lite_update(&lidar_lite_distance);
   \   000000CC   201C               MOV         R0,R4
   \   000000CE   5430               ADD         R0,#+84
   \   000000D0   ........           BL          ??lidar_lite_update
    751                                  scp_num++;
   \   000000D4   A078               LDRB        R0,[R4, #+2]
   \   000000D6   401C               ADD         R0,R0,#+1
   \   000000D8   A070               STRB        R0,[R4, #+2]
    752                                  AT91C_BASE_TC0->TC_RA = AT91C_BASE_TC0 -> TC_CV+350;
   \   000000DA   ....               LDR         R0,??Subroutine24_0+0x30  ;; 0xfffa0010
   \   000000DC   0068               LDR         R0,[R0, #+0]
   \   000000DE   AF21               MOV         R1,#+175
   \   000000E0   4900               LSL         R1,R1,#+1          ;; #+350
   \   000000E2   4018               ADD         R0,R0,R1
   \   000000E4   2860               STR         R0,[R5, #+0]
   \   000000E6   02B0               ADD         SP,#+8
    753                                  break; 
    754                        default : break;
    755                      }
    756                  }
    757               }//HDG==0
    758            }
    759          }
   \                     ??timer0_c_irq_handler_7:
   \   000000E8                      REQUIRE ?Subroutine24
   \   000000E8                      ;; // Fall through to label ?Subroutine24

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   D1070000           DC32        0x7d1

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   00017700           DC32        0x770100

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32        bmp_update_flag

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0080FBFF           DC32        0xfffb8000

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   00011100           DC32        0x110100

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   00017700           DC32        0x770100

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   00011E00           DC32        0x1e0100

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0080FBFF           DC32        0xfffb8000

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   ........           DC32        bmp_update_flag + 52

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   ........           DC32        bmp_update_flag

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   245174CC           DC32        0xcc745124

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   955BC83F           DC32        0x3fc85b95

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   D0BCF840           DC32        0x40f8bcd0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   0000F03F           DC32        0x3ff00000

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   40A5E540           DC32        0x40e5a540

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   00011100           DC32        0x110100

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0080FBFF           DC32        0xfffb8000

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for bmp_update_flag>`:
   \   00000000   00                 DC8 0
   \                     `?<Initializer for imu_num>`:
   \   00000001   00                 DC8 0
   \                     `?<Initializer for scp_num>`:
   \   00000002   00                 DC8 0
   \                     `?<Initializer for HDG>`:
   \   00000003   02                 DC8 2
   \                     `?<Initializer for imu_update_flag>`:
   \   00000004   00                 DC8 0
   \                     `?<Initializer for raw_imu_update>`:
   \   00000005   00                 DC8 0
   \                     `?<Initializer for scp_status>`:
   \   00000006   00                 DC8 0
   \   00000007   00                 DC8 0
   \                     `?<Initializer for temperature>`:
   \   00000008   0000               DC16 0
   \   0000000A   0000               DC8 0, 0
   \                     `?<Initializer for bmp_height>`:
   \   0000000C   000000000000       DC32 0H, 0H
   \              0000        
   \                     `?<Initializer for scp_height>`:
   \   00000014   000000000000       DC32 0H, 0H
   \              0000        
   \                     `?<Initializer for zero_scp_height>`:
   \   0000001C   000000000000       DC32 0H, 0H
   \              0000        
   \                     `?<Initializer for zero_bmp_height>`:
   \   00000024   000000000000       DC32 0H, 0H
   \              0000        
   \                     `?<Initializer for scp_pressure>`:
   \   0000002C   000000000000       DC32 0H, 0H
   \              0000        
   \                     `?<Initializer for p_bmp085>`:
   \   00000034   ........           DC32 bmp085
   \                     `?<Initializer for imu_count>`:
   \   00000038   00000000           DC32 0
   \                     `?<Initializer for timer0_num>`:
   \   0000003C   00000000           DC32 0
   \                     `?<Initializer for up>`:
   \   00000040   00000000           DC32 0
   \                     `?<Initializer for ut>`:
   \   00000044   00000000           DC32 0
   \                     `?<Initializer for pressure>`:
   \   00000048   00000000           DC32 0
   \                     `?<Initializer for zero_count>`:
   \   0000004C   01000000           DC32 1
   \                     `?<Initializer for zero_count>_1`:
   \   00000050   01000000           DC32 1
   \                     `?<Initializer for lidar_lite_distance>`:
   \   00000054   000000000000       DC32 0H, 0H
   \              0000        

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for bmp_h_window>`:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000010   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000030   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     `?<Initializer for bmp_length>`:
   \   00000038   01000000           DC32 1

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for bmp_h_window>_1`:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000010   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000030   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000040   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000050   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000060   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000070   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     `?<Initializer for bmp_length>_1`:
   \   00000078   01000000           DC32 1

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     bmp085_get_cal_param()            40
     bmp085_get_pressure(unsigned long)
                                       20
     bmp085_get_temperature(unsigned long)
                                        8
     bmp085_get_up()                   36
     bmp085_get_ut()                   36
     bmp085_init()                     40
     bmp085_t::AT91F_WaitMiliSecond(unsigned int)
                                        4
     bmp085_t::BMP085_BUS_READ_FUNC(AT91PS_TWI, int, int, unsigned char *, unsigned int)
                                       20
     bmp085_t::BMP085_BUS_WRITE_FUNC(AT91PS_TWI, int, int, unsigned char *, unsigned int)
                                       20
     bmp085_update()                   20
     height_average_filter(double)     40
     height_average_filter_for_scp1000(double)
                                       40
     hmc_get_data(char)                16
     hmc_init()                        36
     hmc_update()                      12
     lidar_lite_update(double *)       20
     scp1000_init()                    28
     scp1000_pressure(double *)        44
     scp1000_update()                  16
     timer0_c_irq_handler()            28


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     bmp085                           40
     compass_update_flag               1
     flag                              4
     pni_value                        12
     scp_opstatus                      1
     bmp085_t::BMP085_BUS_WRITE_FUNC(AT91PS_TWI, int, int, unsigned char *, unsigned int)
                                     144
     ?Subroutine20                     6
     bmp085_t::BMP085_BUS_READ_FUNC(AT91PS_TWI, int, int, unsigned char *, unsigned int)
                                     104
     bmp085_t::AT91F_WaitMiliSecond(unsigned int)
                                      52
     bmp085_init()                   100
     bmp085_get_cal_param()          186
     ?Subroutine21                     6
     bmp085_get_temperature(unsigned long)
                                      48
     bmp085_get_pressure(unsigned long)
                                     180
     bmp085_get_ut()                  86
     ?Subroutine22                     6
     scp1000_init()                   80
     scp1000_pressure(double *)      110
     lidar_lite_update(double *)      72
     height_average_filter(double)   132
     ?Subroutine23                    12
     height_average_filter_for_scp1000(double)
                                     128
     bmp085_get_up()                 124
     hmc_init()                       68
     hmc_get_data(char)               42
     bmp085_update()                 148
     ?Subroutine24                    60
     scp1000_update()                114
     bmp_update_flag                  92
     bmp_h_window                     60
     bmp_h_window                    124
     hmc_update()                    108
     timer0_c_irq_handler()          232
     ??DataTable1                      4
     ??DataTable12                     4
     ??DataTable16                     4
     ??DataTable17                     4
     ??DataTable18                     4
     ??DataTable23                     4
     ??DataTable27                     4
     ??DataTable28                     4
     ??DataTable29                     4
     ??DataTable36                     4
     ??DataTable37                     4
     ??DataTable38                     4
     ??DataTable39                     4
     ??DataTable40                     4
     ??DataTable41                     4
     ??DataTable42                     4
     ??DataTable43                     4
     ?<Initializer for bmp_update_flag>
                                      92
     ?<Initializer for bmp_h_window>
                                      60
     ?<Initializer for bmp_h_window>_1
                                     124
      Others                         328

 
 2 720 bytes in segment CODE
   276 bytes in segment DATA_I
   276 bytes in segment DATA_ID
    58 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 2 416 bytes of CODE  memory (+ 328 bytes shared)
   276 bytes of CONST memory
   334 bytes of DATA  memory

Errors: none
Warnings: none
